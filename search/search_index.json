{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the FastFuels Python SDK Documentation!","text":""},{"location":"#what-is-fastfuels","title":"What is FastFuels?","text":"<p>FastFuels is a cloud-based platform for generating forest inventory data. It</p> <p>uses a combination of satellite imagery and machine learning to generate</p> <p>tabular tree data and voxelized 3D fuel models. These data products can be used</p> <p>to support wildfire risk assessment, fire behavior modeling, and other</p> <p>applications.</p>"},{"location":"#what-is-the-fastfuels-python-sdk","title":"What is the FastFuels Python SDK?","text":"<p>The FastFuels Python SDK is a Python package that provides a convenient</p> <p>interface for interacting with the FastFuels API. It can be used to create and</p> <p>manage FastFuels resources. It can also be used to download and process</p> <p>generated data products.</p>"},{"location":"#installation","title":"Installation","text":"<p>The FastFuels Python SDK can be installed using <code>pip</code> or <code>conda</code>.</p>"},{"location":"#pip","title":"pip","text":"<pre><code>pip install fastfuels-sdk\n</code></pre>"},{"location":"#conda","title":"conda","text":"<p>Conda support is coming soon!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#fastfuels_sdk.domains","title":"fastfuels_sdk.domains","text":"<p>domains.py</p>"},{"location":"reference/#fastfuels_sdk.domains.Domain","title":"Domain","text":"<p>               Bases: <code>Domain</code></p> <p>Domain resource for the FastFuels API.</p> <p>Represents a spatial container that defines geographic boundaries for fire behavior modeling and analysis. A Domain includes metadata like name and description along with geometric data defining its spatial extent. Domains must specify a valid area between 0 and 16 square kilometers.</p> <p>The Domain handles coordinate system transformations automatically: 1. Geographic coordinates (e.g. EPSG:4326) are projected to appropriate UTM zone 2. Projected coordinates are preserved in their original CRS 3. Local coordinates are treated as non-georeferenced 4. Geometries are padded to align with specified grid resolution</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the domain</p> <code>name</code> <code>str</code> <p>Human-readable name for the domain</p> <code>description</code> <code>str</code> <p>Detailed description of the domain</p> <code>type</code> <code>str</code> <p>Always \"FeatureCollection\"</p> <code>features</code> <code>List[dict]</code> <p>GeoJSON features defining domain extent and input geometry</p> <code>horizontal_resolution</code> <code>float</code> <p>Grid cell size in meters for x/y dimensions</p> <code>vertical_resolution</code> <code>float</code> <p>Grid cell size in meters for z dimension</p> <code>crs</code> <code>dict</code> <p>Coordinate reference system specification</p> <code>tags</code> <code>(List[str], optional)</code> <p>User-defined tags for organization</p> <p>Examples:</p> <p>Create domain from GeoJSON:</p> <pre><code>&gt;&gt;&gt; with open(\"area.geojson\") as f:\n...     geojson = json.load(f)\n&gt;&gt;&gt; domain = Domain.from_geojson(\n...     geojson,\n...     name=\"Test Domain\",\n...     horizontal_resolution=2.0\n... )\n</code></pre> <p>Get domain by ID:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_id(\"abc123\")\n&gt;&gt;&gt; print(domain.name)\n'Test Domain'\n</code></pre> See Also <p>Domain.from_geojson : Create domain from GeoJSON data Domain.from_geodataframe : Create domain from GeoPandas GeoDataFrame Domain.to_dict : Export domain as dictionary Domain.to_json : Export domain as JSON string Domain.to_geodataframe : Convert domain to GeoPandas GeoDataFrame list_domains : List available domains</p>"},{"location":"reference/#fastfuels_sdk.domains.Domain.from_id","title":"from_id  <code>classmethod</code>","text":"<pre><code>from_id(domain_id: str) -&gt; Domain\n</code></pre> <p>Retrieve an existing Domain resource by its ID.</p> <p>Fetches a Domain from the FastFuels API using its unique identifier. Raises NotFoundException if no domain exists with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>The unique identifier of the domain to retrieve</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The requested Domain object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_domain_id(\"abc123\")\n&gt;&gt;&gt; domain.id\n'abc123'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.domains.Domain.from_geojson","title":"from_geojson  <code>classmethod</code>","text":"<pre><code>from_geojson(geojson: dict, name: str = '', description: str = '', horizontal_resolution: float = 2.0, vertical_resolution: float = 1.0) -&gt; Domain\n</code></pre> <p>Create a new Domain resource from GeoJSON data.</p> <p>Creates and stores a spatial Domain in the FastFuels API that serves as a geographic container for other system resources. The Domain is defined by GeoJSON geometry which must specify a valid area between 0 and 16 square kilometers.</p> <p>The system processes the input geometry in several ways: 1. If geographic coordinates (e.g. EPSG:4326) are provided, they are automatically projected    to the appropriate UTM zone for accurate spatial operations 2. If already in a projected coordinate system, the input CRS is preserved 3. If specified as 'local', the coordinates are treated as non-georeferenced 4. The geometry's bounding box is calculated and padded to align with the specified grid    resolution</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>A GeoJSON dictionary containing either a Feature or FeatureCollection. Must include a valid geometry defining the spatial location of the domain.</p> required <code>name</code> <code>str</code> <p>Name for the domain resource, default \"\"</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of the domain resource, default \"\"</p> <code>''</code> <code>horizontal_resolution</code> <code>float</code> <p>Horizontal resolution in meters for grid representation, default 2.0</p> <code>2.0</code> <code>vertical_resolution</code> <code>float</code> <p>Vertical resolution in meters for grid representation, default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The newly created Domain object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"my_file.geojson\") as f:\n...     my_geojson = json.load(f)\n&gt;&gt;&gt; domain = Domain.from_geojson(\n...     geojson=my_geojson,\n...     name=\"my domain\",\n...     description=\"A domain for testing\",\n...     horizontal_resolution=2.0,\n...     vertical_resolution=1.0\n... )\n&gt;&gt;&gt; domain.id\n'abc123...'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.domains.Domain.from_geodataframe","title":"from_geodataframe  <code>classmethod</code>","text":"<pre><code>from_geodataframe(geodataframe, name: str = '', description: str = '', horizontal_resolution: float = 2.0, vertical_resolution: float = 1.0)\n</code></pre> <p>Create a new Domain resource from a GeoDataFrame.</p> <p>The Domain acts as a spatial container in the FastFuels API, defining the geographic boundaries for fire behavior modeling and analysis. This method provides a convenient way to create a Domain from existing geospatial data loaded in a GeoDataFrame.</p> <p>The GeoDataFrame's geometry undergoes several processing steps: 1. For data in geographic coordinates (e.g. EPSG:4326), the system automatically projects to   the appropriate UTM zone based on the geometry's centroid. This ensures accurate distance   and area calculations. 2. If the data is already in a projected coordinate system (e.g. NAD83 / UTM or State Plane),   that CRS is preserved to maintain consistency with existing data. 3. For local coordinate systems, the geometry is treated as non-georeferenced and no   projection is performed. 4. The system calculates a bounding box around the geometry and pads it to align with the   specified resolution, ensuring proper grid alignment for analysis.</p> <p>One key advantage of using GeoDataFrames is the ability to read from multiple file formats. The same Domain creation process works whether your data comes from Shapefiles, KML, GeoJSON, or other formats supported by geopandas.</p> <p>Input geometry must define a valid area between 0 and 16 square kilometers to ensure efficient processing and analysis.</p> <p>Parameters:</p> Name Type Description Default <code>geodataframe</code> <code>GeoDataFrame</code> <p>Geopandas GeoDataFrame object containing the geometry defining the domain.</p> required <code>name</code> <code>str</code> <p>Name for the domain resource, default \"\"</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of the domain resource, default \"\"</p> <code>''</code> <code>horizontal_resolution</code> <code>float</code> <p>Horizontal resolution in meters for grid representation, default 2.0</p> <code>2.0</code> <code>vertical_resolution</code> <code>float</code> <p>Vertical resolution in meters for grid representation, default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The newly created Domain object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; gdf = gpd.read_file(\"blue_mtn.shp\")  # Can read shp, geojson, kml, etc.\n&gt;&gt;&gt; domain = Domain.from_geodataframe(\n...     gdf,\n...     name=\"test_domain\",\n...     description=\"Domain from shapefile\",\n...     horizontal_resolution=2.0,\n...     vertical_resolution=1.0\n... )\n&gt;&gt;&gt; domain.name\n'test_domain'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.domains.Domain.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; Domain\n</code></pre> <p>Retrieve the latest domain data from the API.</p> <p>This method fetches the most recent data for this domain from the API. It can either update the current Domain instance in-place or return a new instance with the fresh data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates the current Domain instance with the new data and returns self. If False, returns a new Domain instance with the latest data, leaving the current instance unchanged. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Domain</code> <p>Either the current Domain instance (if in_place=True) or a new Domain instance (if in_place=False) containing the latest data from the API.</p> <p>Examples:</p> <p>Create new instance with latest data:</p> <pre><code>&gt;&gt;&gt; domain = Domain.get_domain(\"123\")\n&gt;&gt;&gt; updated_domain = domain.get()  # domain remains unchanged\n&gt;&gt;&gt; updated_domain is domain\nFalse\n</code></pre> <p>Update existing instance in-place:</p> <pre><code>&gt;&gt;&gt; domain = Domain.get_domain(\"123\")\n&gt;&gt;&gt; domain.get(in_place=True)  # domain is updated\n&gt;&gt;&gt; # Any references to domain now see the updated data\n</code></pre> Notes <p>The default behavior (in_place=False) ensures immutability by returning a new instance. This is safer for concurrent operations but requires reassignment if you want to retain the updated data. Use in_place=True when you want to ensure all references to this Domain instance see the updated data.</p>"},{"location":"reference/#fastfuels_sdk.domains.Domain.update","title":"update","text":"<pre><code>update(name: Optional[str] = None, description: Optional[str] = None, tags: Optional[List[str]] = None, in_place: bool = False) -&gt; Domain\n</code></pre> <p>Update the domain's mutable properties.</p> <p>This method allows updating the name, description, and tags of a domain. Other properties cannot be modified - a new domain must be created instead.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>New name for the domain</p> <code>None</code> <code>description</code> <code>str</code> <p>New description for the domain</p> <code>None</code> <code>tags</code> <code>List[str]</code> <p>New list of tags for the domain</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>If True, updates the current Domain instance with the new data and returns self. If False, returns a new Domain instance with the updated data, leaving the current instance unchanged. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Domain</code> <p>Either the current Domain instance (if in_place=True) or a new Domain instance (if in_place=False) containing the updated data.</p> <p>Examples:</p> <p>Update and get new instance:</p> <pre><code>&gt;&gt;&gt; domain = Domain.get_domain(\"123\")\n&gt;&gt;&gt; updated = domain.update(name=\"New Name\")  # domain remains unchanged\n&gt;&gt;&gt; updated.name\n'New Name'\n</code></pre> <p>Update in-place:</p> <pre><code>&gt;&gt;&gt; domain = Domain.get_domain(\"123\")\n&gt;&gt;&gt; domain.update(name=\"New Name\", in_place=True)  # domain is modified\n&gt;&gt;&gt; domain.name\n'New Name'\n</code></pre> Notes <p>Only name, description, and tags can be updated. Other properties like horizontal_resolution, vertical_resolution, features, etc. cannot be modified - you must create a new domain instead.</p>"},{"location":"reference/#fastfuels_sdk.domains.Domain.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Serialize the entire Domain object to JSON string.</p> <p>Returns the complete Domain object as a JSON string, including all attributes like id, name, description, features, CRS, resolutions, timestamps, etc. Uses clean serialization without internal Pydantic validation fields.</p> <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation of the complete Domain object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_id(\"abc123\")\n&gt;&gt;&gt; json_str = domain.to_json()\n&gt;&gt;&gt; with open(\"domain.json\", \"w\") as f:\n...     f.write(json_str)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.domains.Domain.to_geodataframe","title":"to_geodataframe","text":"<pre><code>to_geodataframe() -&gt; gpd.GeoDataFrame\n</code></pre> <p>Convert the Domain to a GeoPandas GeoDataFrame.</p> <p>Creates a GeoDataFrame containing the Domain's geometry and attributes. This provides a convenient way to work with Domain data using GeoPandas for spatial analysis, visualization, or export to various geospatial file formats.</p> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with the Domain's features and CRS information</p> <p>Examples:</p> <p>Convert to GeoDataFrame:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_id(\"abc123\")\n&gt;&gt;&gt; gdf = domain.to_geodataframe()\n&gt;&gt;&gt; print(gdf.crs)\n&gt;&gt;&gt; print(gdf.geometry)\n</code></pre> <p>Export to shapefile:</p> <pre><code>&gt;&gt;&gt; gdf = domain.to_geodataframe()\n&gt;&gt;&gt; gdf.to_file(\"domain.shp\")\n</code></pre> <p>Spatial analysis:</p> <pre><code>&gt;&gt;&gt; gdf = domain.to_geodataframe()\n&gt;&gt;&gt; area = gdf.geometry.area.sum()\n&gt;&gt;&gt; print(f\"Domain area: {area} square units\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.domains.Domain.export","title":"export","text":"<pre><code>export() -&gt; dict\n</code></pre> <p>Export all domain metadata including features, grids, and inventories.</p> <p>Returns domain configuration and metadata for all resources without including large data payloads like grid arrays, GeoJSON features, or tree records.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing: - domain: Full domain metadata (id, name, description, resolutions, CRS, etc.) - features: Feature metadata excluding GeoJSON data - grids: Grid metadata excluding array data - inventories: Inventory metadata excluding tree records</p> <p>Examples:</p> <p>Export domain metadata:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_id(\"abc123\")\n&gt;&gt;&gt; export_data = domain.export()\n&gt;&gt;&gt; print(export_data['domain']['name'])\n'My Domain'\n&gt;&gt;&gt; print(export_data['grids']['tree']['status'])\n'completed'\n</code></pre> <p>Save export to file:</p> <pre><code>&gt;&gt;&gt; export_data = domain.export()\n&gt;&gt;&gt; with open('domain_export.json', 'w') as f:\n...     json.dump(export_data, f, indent=2)\n</code></pre> Notes <p>Large data payloads are excluded to keep response size manageable: - Feature GeoJSON: Use dedicated feature export endpoints - Grid array data: Use grid export endpoints - Tree inventory records: Use inventory export endpoints</p>"},{"location":"reference/#fastfuels_sdk.domains.Domain.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete an existing domain resource based on the domain ID.</p> <p>The Domain object becomes invalid after deletion and should not be used for further operations. Doing so will raise a NotFoundException.</p> <p>Returns:</p> Type Description <code>None</code> <p>Returns None on successful deletion</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_id(\"abc123\")\n&gt;&gt;&gt; domain.delete()  # Domain resource is permanently deleted\n</code></pre> <p>Perform operations on a deleted domain:</p> <pre><code>&gt;&gt;&gt; domain.get()\n# Raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.domains.list_domains","title":"list_domains","text":"<pre><code>list_domains(page: Optional[int] = None, size: Optional[int] = None, sort_by: Optional[str] = None, sort_order: Optional[str] = None) -&gt; ListDomainResponse\n</code></pre> <p>Retrieve a paginated list of all domains accessible to the authenticated user.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The page number to retrieve (zero-indexed). Default is 0.</p> <code>None</code> <code>size</code> <code>int</code> <p>Number of domains to return per page. Must be between 1 and 1000. Default is 100.</p> <code>None</code> <code>sort_by</code> <code>str</code> <p>Field to sort the domains by. Valid values are: - \"createdOn\" - \"modifiedOn\" - \"name\" Default is \"createdOn\".</p> <code>None</code> <code>sort_order</code> <code>str</code> <p>Order in which to sort the results. Valid values are: - \"ascending\" - \"descending\" Default is \"ascending\".</p> <code>None</code> <p>Returns:</p> Type Description <code>ListDomainResponse</code> <p>A response object containing: - domains: List of Domain objects - currentPage: Current page number - pageSize: Number of domains per page - totalItems: Total number of domains available</p> <p>Examples:</p> <p>Get first page with default settings:</p> <pre><code>&gt;&gt;&gt; response = list_domains()\n&gt;&gt;&gt; print(f\"Found {len(response.domains)} domains\")\n</code></pre> <p>Get specific page with custom size:</p> <pre><code>&gt;&gt;&gt; response = list_domains(page=2, size=50)\n&gt;&gt;&gt; for domain in response.domains:\n...     print(f\"Domain {domain.id}: {domain.name}\")\n</code></pre> <p>Sort domains by name:</p> <pre><code>&gt;&gt;&gt; response = list_domains(sort_by=\"name\", sort_order=\"ascending\")\n</code></pre> Notes <ul> <li>Page numbers are zero-indexed, meaning the first page is 0.</li> <li>If no pagination parameters are provided, defaults to page 0 with 100 items.</li> <li>The maximum page size is 1000 items.</li> <li>When calculating total pages, use: ceil(response.totalItems / response.pageSize)</li> </ul>"},{"location":"reference/#fastfuels_sdk.inventories","title":"fastfuels_sdk.inventories","text":"<p>inventories.py</p>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories","title":"Inventories","text":"<p>               Bases: <code>Inventories</code></p> <p>This class serves as an interface for interacting with the inventory data associated with a particular domain. It provides methods to fetch, update, and initialize inventory data from the API.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>The ID of the domain associated with the inventory.</p> <code>tree</code> <code>(TreeInventory, optional)</code> <p>The tree inventory data associated with the domain. By default, this attribute is <code>None</code>.</p>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; Inventories\n</code></pre> <p>Constructs an <code>Inventories</code> instance from a given <code>Domain</code> object.</p> <p>This class method interacts with the API to fetch the inventory data associated with the provided domain ID. The fetched data is then used to initialize and return an <code>Inventories</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>The ID of the domain to fetch inventory data for.</p> required <p>Returns:</p> Type Description <code>Inventories</code> <p>An instance of <code>Inventories</code> initialized with inventory data fetched using the domain ID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Inventories\n&gt;&gt;&gt; inventories = Inventories.from_domain_id(\"abc123\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories.get","title":"get","text":"<pre><code>get(in_place: bool = False)\n</code></pre> <p>Fetches the inventory data associated with the domain ID.</p> <p>This method interacts with the API to fetch the inventory data associated with the domain ID. The fetched data is then used to update the <code>Inventories</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If <code>True</code>, the method updates the current object with the fetched data. If <code>False</code>, the method returns a new object with the fetched data. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Inventories</code> <p>An instance of <code>Inventories</code> updated with the fetched inventory data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Inventories\n&gt;&gt;&gt; inventories = Inventories.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Fetch and update the inventory data\n&gt;&gt;&gt; updated_inventories = inventories.get()\n&gt;&gt;&gt; # Fetch and update the inventory data in place\n&gt;&gt;&gt; inventories.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories.create_tree_inventory","title":"create_tree_inventory","text":"<pre><code>create_tree_inventory(sources: str | list[str] | TreeInventorySource | list[TreeInventorySource], tree_map: Optional[TreeMapSource | dict] = None, modifications: Optional[dict | list[dict]] = None, treatments: Optional[dict | list[dict]] = None, feature_masks: Optional[str | list[str]] = None, in_place: bool = False) -&gt; TreeInventory\n</code></pre> <p>Create a tree inventory for the current domain.</p> <p>This method generates a tree inventory using specified data sources and configurations. A tree inventory represents a complete forest inventory within the spatial context of your domain. Currently, TreeMap is the primary supported data source, providing nationwide coverage of tree data.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>str or list[str] or TreeInventorySource</code> <p>Data source(s) to use for the tree inventory. Currently supports: - \"TreeMap\": Uses the TreeMap raster product for nationwide coverage</p> required <code>tree_map</code> <code>TreeMapSource or dict</code> <p>Configuration for TreeMap source if being used. Can be provided as a dict with: - version: \"2014\", \"2016\", \"2020\", or \"2022\" (default: \"2022\") - seed: Integer for reproducible generation (optional)</p> <code>None</code> <code>modifications</code> <code>dict or list[dict]</code> <p>Rules for modifying or removing tree attributes. Each modification has: - conditions: List of conditions that trees must meet - actions: List of actions to apply to matching trees</p> <p>Conditions can be: 1. Simple field conditions: Compare a single field to a value 2. Expression-based conditions: Use arithmetic expressions combining multiple fields</p> <p>Example - Modify attribute: <pre><code>{\n    \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n    \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n}\n</code></pre></p> <p>Example - Remove all trees with a diameter (DIA) less than 10cm: <pre><code>{\n    \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n    \"actions\": [{\"modifier\": \"remove\"}]\n}\n</code></pre></p> <p>Example - Expression-based condition (remove trees with crown length &lt; 1m): <pre><code>{\n    \"conditions\": [{\n        \"attribute\": \"expression\",\n        \"expression\": \"HT * CR\",  # Crown length calculation\n        \"operator\": \"lt\",\n        \"value\": 1.0\n    }],\n    \"actions\": [{\"modifier\": \"remove\"}]\n}\n</code></pre></p> <p>Example - Multiple conditions (remove tall, slender Douglas-fir): <pre><code>{\n    \"conditions\": [\n        {\"attribute\": \"SPCD\", \"operator\": \"eq\", \"value\": 202},\n        {\"attribute\": \"expression\", \"expression\": \"HT / DIA\", \"operator\": \"gt\", \"value\": 100}\n    ],\n    \"actions\": [{\"modifier\": \"remove\"}]\n}\n</code></pre></p> <p>Available field attributes: HT (height), DIA (diameter), CR (crown ratio), SPCD (species code) Available operators: eq, ne, gt, lt, ge, le Available modifiers: multiply, divide, add, subtract, replace, remove</p> <p>Expression syntax: - Fields: HT, DIA, CR - Operators: +, -, *, /, () - Example expressions: \"HT * CR\", \"HT / DIA\", \"(HT + DIA) / 2\", \"HT * (1 - CR)\" - Common patterns:   * Crown length: HT * CR   * Crown base height: HT * (1 - CR)   * Slenderness ratio: HT / DIA</p> <code>None</code> <code>treatments</code> <code>dict or list[dict]</code> <p>List of silvicultural treatments to apply. Supports:</p> <p>Proportional Thinning: <pre><code>{\n    \"method\": \"proportionalThinning\",\n    \"targetMetric\": \"basalArea\",\n    \"targetValue\": 25.0  # in m\u00b2/ha\n}\n</code></pre></p> <p>Directional Thinning: <pre><code>{\n    \"method\": \"directionalThinning\",\n    \"direction\": \"below\",  # or \"above\"\n    \"targetMetric\": \"diameter\",  # or \"basalArea\"\n    \"targetValue\": 30.0  # cm for diameter, m\u00b2/ha for basalArea\n}\n</code></pre></p> <code>None</code> <code>feature_masks</code> <code>str or list[str]</code> <p>Features to mask out from the inventory. Supported values: [\"road\", \"water\"]</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>If True, updates this object's tree inventory (self.tree). If False (default), leaves this object unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeInventory</code> <p>The newly created tree inventory object.</p> Notes <ul> <li>The inventory generation happens asynchronously. The returned inventory   will initially have a \"pending\" status.</li> <li>Using the same seed value will generate the same trees when all other   parameters are identical.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Inventories\n&gt;&gt;&gt; inventories = Inventories.from_domain_id(\"abc123\")\n</code></pre> <p>Basic usage with TreeMap:</p> <pre><code>&gt;&gt;&gt; inventory = inventories.create_tree_inventory(sources=\"TreeMap\")\n</code></pre> <p>Specify TreeMap version and seed:</p> <pre><code>&gt;&gt;&gt; inventory = inventories.create_tree_inventory(\n...     sources=\"TreeMap\",\n...     tree_map={\"version\": \"2014\", \"seed\": 42}\n... )\n</code></pre> <p>Add height modification:</p> <pre><code>&gt;&gt;&gt; inventory = inventories.create_tree_inventory(\n...     sources=\"TreeMap\",\n...     modifications={\n...         \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n...         \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n...     }\n... )\n</code></pre> <p>Remove small trees:</p> <pre><code>&gt;&gt;&gt; inventory = inventories.create_tree_inventory(\n...     sources=\"TreeMap\",\n...     modifications={\n...         \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n...         \"actions\": [{\"attribute\": \"all\", \"modifier\": \"remove\"}]\n...     }\n... )\n</code></pre> <p>Add proportional thinning treatment:</p> <pre><code>&gt;&gt;&gt; inventory = inventories.create_tree_inventory(\n...     sources=\"TreeMap\",\n...     treatments={\n...         \"method\": \"proportionalThinning\",\n...         \"targetMetric\": \"basalArea\",\n...         \"targetValue\": 25.0\n...     }\n... )\n</code></pre> <p>Mask out roads and water:</p> <pre><code>&gt;&gt;&gt; inventory = inventories.create_tree_inventory(\n...     sources=\"TreeMap\",\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories.create_tree_inventory_from_treemap","title":"create_tree_inventory_from_treemap","text":"<pre><code>create_tree_inventory_from_treemap(version: str = '2022', seed: int = None, canopy_height_map_source: Optional[str] = None, modifications: Optional[dict | list[dict]] = None, treatments: Optional[dict | list[dict]] = None, feature_masks: Optional[str | list[str]] = None, in_place: bool = False) -&gt; TreeInventory\n</code></pre> <p>Create a tree inventory using TreeMap data for the current domain.</p> <p>This is a convenience method that provides a simplified interface for creating tree inventories specifically from TreeMap data. While create_tree_inventory() offers a more general interface supporting multiple data sources, this method is optimized for the common case of using TreeMap data with a focus on the most relevant parameters.</p> <p>Use this method when: - You want to create an inventory using TreeMap data (most common case) - You prefer a simpler interface focused on TreeMap-specific parameters - You want clearer defaults and documentation for TreeMap usage</p> <p>Use create_tree_inventory() instead when: - You need to use data sources other than TreeMap - You prefer more explicit control over source configuration - You need to specify multiple data sources</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>The TreeMap version to use. Available versions: - \"2022\" (default) - \"2020\" - \"2016\" - \"2014\"</p> <code>'2022'</code> <code>seed</code> <code>int</code> <p>Random seed for reproducible tree generation. When provided, generates identical trees for the same domain and parameters. If omitted, generates different trees each time.</p> <code>None</code> <code>canopy_height_map_source</code> <code>str</code> <p>High-resolution canopy height map source for improved tree height estimates. When specified, fuses canopy height data with TreeMap to provide more accurate height information. Available sources: - \"Meta2024\": Meta's 2024 global canopy height map at 1-meter resolution</p> <code>None</code> <code>modifications</code> <code>dict or list[dict]</code> <p>Rules for modifying or removing tree attributes. Each modification includes: - conditions: List of criteria that trees must meet (all must be true - AND logic) - actions: Changes to apply to matching trees</p> <p>Conditions support both simple field comparisons and arithmetic expressions combining multiple fields.</p> <p>Example - Modify attribute: <pre><code>{\n    \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n    \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n}\n</code></pre></p> <p>Example - Remove trees (simplified syntax): <pre><code>{\n    \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n    \"actions\": [{\"modifier\": \"remove\"}]\n}\n</code></pre></p> <p>Example - Expression-based (remove trees with short crowns): <pre><code>{\n    \"conditions\": [{\n        \"attribute\": \"expression\",\n        \"expression\": \"HT * CR\",  # Crown length\n        \"operator\": \"lt\",\n        \"value\": 1.0\n    }],\n    \"actions\": [{\"modifier\": \"remove\"}]\n}\n</code></pre></p> <p>Example - Multiple conditions (remove unrealistic slender trees): <pre><code>{\n    \"conditions\": [\n        {\"attribute\": \"expression\", \"expression\": \"HT / DIA\", \"operator\": \"gt\", \"value\": 100},\n        {\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 5}\n    ],\n    \"actions\": [{\"modifier\": \"remove\"}]\n}\n</code></pre></p> <p>Available field attributes: - HT: Height (meters) - DIA: Diameter at breast height (centimeters) - CR: Crown ratio (0-1) - SPCD: Species code (integer)</p> <p>Available operators: eq, ne, gt, lt, ge, le Available modifiers: multiply, divide, add, subtract, replace, remove</p> <p>Expression syntax (for expression-based conditions): - Fields: HT, DIA, CR - Operators: +, -, *, /, () - Common patterns: \"HT * CR\" (crown length), \"HT / DIA\" (slenderness), \"HT * (1 - CR)\" (crown base height)</p> <code>None</code> <code>treatments</code> <code>dict or list[dict]</code> <p>Silvicultural treatments to apply. Supports:</p> <p>Proportional Thinning - Reduces stand density to target basal area: <pre><code>{\n    \"method\": \"proportionalThinning\",\n    \"targetMetric\": \"basalArea\",\n    \"targetValue\": 25.0  # Target basal area in m\u00b2/ha\n}\n</code></pre></p> <p>Directional Thinning - Removes trees based on size: <pre><code>{\n    \"method\": \"directionalThinning\",\n    \"direction\": \"below\",  # \"below\" or \"above\"\n    \"targetMetric\": \"diameter\",  # \"diameter\" or \"basalArea\"\n    \"targetValue\": 30.0  # cm for diameter, m\u00b2/ha for basalArea\n}\n</code></pre></p> <code>None</code> <code>feature_masks</code> <code>str or list[str]</code> <p>Features to exclude from the inventory by removing trees that intersect with them. Available masks: - \"road\": Removes trees on roads - \"water\": Removes trees in water bodies</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>Controls whether to update the current Inventories object: - If True, updates this object's tree inventory (self.tree) - If False (default), returns new inventory without modifying current object</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeInventory</code> <p>The newly created tree inventory object.</p> Notes <ul> <li>Generation is asynchronous - the inventory starts in \"pending\" status</li> <li>Final generation can take several minutes depending on domain size</li> <li>Check inventory.status for current state: \"pending\", \"running\", \"completed\"</li> <li>TreeMap accuracy varies by region and forest type</li> <li>Use same seed value to reproduce exact tree patterns</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Inventories\n&gt;&gt;&gt; inventories = Inventories.from_domain_id(\"abc123\")\n</code></pre> <p>Basic inventory creation:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap()\n</code></pre> <p>Reproducible inventory with specific version:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     version=\"2014\",\n...     seed=42\n... )\n</code></pre> <p>Reduce height of tall trees:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     modifications={\n...         \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n...         \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n...     }\n... )\n</code></pre> <p>Remove small trees:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     modifications={\n...         \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n...         \"actions\": [{\"attribute\": \"all\", \"modifier\": \"remove\"}]\n...     }\n... )\n</code></pre> <p>Thin to target basal area:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     treatments={\n...         \"method\": \"proportionalThinning\",\n...         \"targetMetric\": \"basalArea\",\n...         \"targetValue\": 25.0\n...     }\n... )\n</code></pre> <p>Remove trees from roads and water:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre> <p>Combined modifications, thinning, and masks:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     seed=42,\n...     modifications={\n...         \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n...         \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n...     },\n...     treatments={\n...         \"method\": \"proportionalThinning\",\n...         \"targetMetric\": \"basalArea\",\n...         \"targetValue\": 25.0\n...     },\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre> <p>Apply a high resolution canopy height map data fusion:</p> <pre><code>&gt;&gt;&gt; tree_inventory = inventories.create_tree_inventory_from_treemap(\n...     canopy_height_map_source=\"Meta2024\"\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories.create_tree_inventory_from_file_upload","title":"create_tree_inventory_from_file_upload","text":"<pre><code>create_tree_inventory_from_file_upload(file_path: Path | str) -&gt; TreeInventory\n</code></pre> <p>Create a tree inventory using a file upload for the current domain.</p> <p>This method uploads a CSV file containing tree inventory data and creates a new tree inventory for the domain. The file must follow specific format requirements and contain required columns with appropriate data types.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path or str</code> <p>Path to the CSV file containing the tree inventory data. The file must include the following columns: - TREE_ID (Integer): Unique identifier for each tree - SPCD (Integer): FIA species code - STATUSCD (Integer): Tree status code (0: No status, 1: Live, 2: Dead, 3: Missing) - DIA (Float): Diameter at breast height in cm (0-1200 cm, nullable) - HT (Float): Tree height in meters (0-116 m, nullable) - CR (Float): Crown ratio (0-1, nullable) - X (Float): X coordinate in projected coordinate system (nullable) - Y (Float): Y coordinate in projected coordinate system (nullable)</p> required <p>Returns:</p> Type Description <code>TreeInventory</code> <p>A TreeInventory object representing the newly created inventory. The inventory starts in \"pending\" status and is processed asynchronously. Use wait_until_completed() to wait for processing to finish.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified file_path does not exist.</p> <code>ValueError</code> <p>If the file size exceeds 500MB or if the file is not a CSV.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Inventories\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; inventories = Inventories.from_domain_id(\"abc123\")\n&gt;&gt;&gt; file_path = Path(\"my_trees.csv\")\n&gt;&gt;&gt; # Create and wait for inventory\n&gt;&gt;&gt; inventory = inventories.create_tree_inventory_from_file_upload(file_path)\n&gt;&gt;&gt; inventory = inventory.wait_until_completed()\n&gt;&gt;&gt; print(inventory.status)\n'completed'\n</code></pre> Notes <p>File Format Requirements: - Maximum file size: 500MB - File type: CSV - Must include all required columns with correct data types - TREE_ID must be unique integers - Values must be within specified ranges - Trees must fall within domain bounds</p>"},{"location":"reference/#fastfuels_sdk.inventories.Inventories.create_tree_inventory_from_point_cloud","title":"create_tree_inventory_from_point_cloud","text":"<pre><code>create_tree_inventory_from_point_cloud(in_place: bool = False) -&gt; TreeInventory\n</code></pre> <p>Create a tree inventory derived from the domain's point cloud data. This method initiates the creation of a tree inventory by processing the Airborne Laser Scanning (ALS) point cloud associated with this domain. Individual trees are segmented from the point cloud to derive tree locations and heights. Prerequisites: - The domain must have an existing ALS point cloud resource (see PointClouds). - The point cloud status must be 'completed'.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this Inventories object's tree inventory (self.tree). If False (default), returns a new inventory object without modifying this instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeInventory</code> <p>The newly created tree inventory object. Initially in 'pending' status.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Inventories\n&gt;&gt;&gt; inventories = Inventories.from_domain_id(\"abc123\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create tree inventory from existing point cloud\n&gt;&gt;&gt; inventory = inventories.create_tree_inventory_from_point_cloud()\n&gt;&gt;&gt; inventory.wait_until_completed()\n</code></pre>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory","title":"TreeInventory","text":"<p>               Bases: <code>TreeInventory</code></p> <p>A class representing a forest inventory within a spatial domain.</p> <p>The TreeInventory class provides access to tree inventory data and operations for a specific domain. It supports creating inventories from various data sources (primarily TreeMap), monitoring inventory processing status, applying modifications and treatments, and exporting data in multiple formats.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>The unique identifier of the domain this inventory belongs to.</p> <code>status</code> <code>str</code> <p>Current processing status of the inventory: - \"pending\": Initial state after creation - \"running\": Being processed - \"completed\": Ready for use - \"failed\": Processing encountered an error</p> <code>created_on</code> <code>datetime</code> <p>When the inventory was created.</p> <code>modified_on</code> <code>datetime</code> <p>When the inventory was last modified.</p> <code>checksum</code> <code>str</code> <p>Unique identifier for this version of the inventory.</p> <code>sources</code> <code>list[str]</code> <p>Data sources used to generate the inventory (e.g. [\"TreeMap\"]).</p> <code>tree_map</code> <code>(TreeMapSource, optional)</code> <p>Configuration used for TreeMap source, if applicable.</p> <code>modifications</code> <code>(list[TreeInventoryModification], optional)</code> <p>Applied modifications to tree attributes.</p> <code>treatments</code> <code>(list[TreeInventoryTreatment], optional)</code> <p>Applied silvicultural treatments.</p> <code>feature_masks</code> <code>(list[str], optional)</code> <p>Applied feature masks (e.g. [\"road\", \"water\"]).</p> <p>Methods:</p> Name Description <code>from_domain</code> <p>Retrieve an existing inventory for a domain.</p> <code>get</code> <p>Fetch the latest inventory data.</p> <code>wait_until_completed</code> <p>Wait for inventory processing to finish.</p> <code>delete</code> <p>Permanently remove this inventory.</p> <code>create_export</code> <p>Create an export of the inventory data.</p> <code>get_export</code> <p>Check status of an existing export.</p> Notes <ul> <li>Tree inventories are created using Inventories.create_tree_inventory() or     Inventories.create_tree_inventory_from_treemap()</li> <li>Processing is asynchronous - use wait_until_completed() to wait for the   \"completed\" status</li> <li>Processing time varies with domain size, modifications, and treatments</li> <li>Once completed, inventories can be exported to CSV, Parquet, or GeoJSON formats</li> <li>A domain can only have one tree inventory at a time</li> </ul> See Also <p>Domain : Spatial container for inventory data Inventories : Container for domain inventory resources Export : Handles exporting inventory data</p>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; TreeInventory\n</code></pre> <p>Retrieve an existing tree inventory for a domain.</p> <p>This method fetches the tree inventory data associated with the provided domain. The tree inventory represents a complete forest inventory within the spatial context of your domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>The ID of the domain to retrieve the tree inventory for.</p> required <p>Returns:</p> Type Description <code>TreeInventory</code> <p>A TreeInventory object containing the retrieved inventory data.</p> <p>Raises:</p> Type Description <code>NotFoundException</code> <p>If no tree inventory exists for the given domain or if the domain itself does not exist.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeInventory\n&gt;&gt;&gt; inventory = TreeInventory.from_domain_id(\"abc123\")\n&gt;&gt;&gt; print(inventory.status)\n'completed'\n</code></pre> Notes <ul> <li>Tree inventories are typically created using Domain.create_tree_inventory() or   Domain.create_tree_inventory_from_treemap()</li> <li>A domain can only have one tree inventory at a time</li> <li>Use get() to refresh the inventory data and wait_until_completed() to wait   for processing to finish</li> </ul>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory.get","title":"get","text":"<pre><code>get(in_place: bool = False)\n</code></pre> <p>Fetch the latest tree inventory data from the API.</p> <p>This method retrieves the most recent tree inventory data for the domain, allowing you to check the current status and access updated information. You can either update the current TreeInventory instance in-place or get a new instance with the fresh data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates the current TreeInventory instance with the new data and returns self. If False (default), returns a new TreeInventory instance with the latest data, leaving the current instance unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeInventory</code> <p>Either the current TreeInventory instance (if in_place=True) or a new TreeInventory instance (if in_place=False) containing the latest data. Key attributes that may be updated include: - status: Current processing status - modified_on: Last modification timestamp - checksum: Unique identifier for this version - sources: Data sources used - tree_map: TreeMap configuration - modifications: Applied modifications - treatments: Applied treatments - feature_masks: Applied masks</p> <p>Raises:</p> Type Description <code>NotFoundException</code> <p>If the tree inventory or domain no longer exists</p> <code>ApiException</code> <p>If there is an error communicating with the API</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeInventory\n&gt;&gt;&gt; inventory = TreeInventory.from_domain_id(\"abc123\")\n</code></pre> <p>Create new instance with latest data:</p> <pre><code>&gt;&gt;&gt; updated = inventory.get()  # inventory remains unchanged\n&gt;&gt;&gt; updated is inventory\nFalse\n</code></pre> <p>Update existing instance in-place:</p> <pre><code>&gt;&gt;&gt; inventory.get(in_place=True)  # inventory is updated\n&gt;&gt;&gt; # Any references to inventory now see the updated data\n</code></pre> Notes <ul> <li>The default behavior (in_place=False) ensures immutability by returning   a new instance. This is safer for concurrent operations but requires   reassignment if you want to retain the updated data.</li> <li>Use in_place=True when you want to ensure all references to this   TreeInventory instance see the updated data.</li> <li>This method is often used in conjunction with wait_until_completed()   to monitor the progress of tree inventory processing.</li> </ul>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; TreeInventory\n</code></pre> <p>Wait for the tree inventory processing to complete.</p> <p>Tree inventories are processed asynchronously and may take between several seconds to minutes to complete depending on domain size and complexity. This method polls the API at regular intervals until the inventory reaches a 'completed' status or the timeout is reached.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Number of seconds to wait between status checks. Default is 5 seconds. Use larger values to reduce API calls, smaller values for more frequent updates.</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum number of seconds to wait for completion. Default is 600 seconds (10 minutes). If the timeout is reached before completion, raises a TimeoutError.</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates the current TreeInventory instance with new data at each check. If False, leaves the current instance unchanged and returns a new instance when complete.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates at each check. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeInventory</code> <p>Either the current TreeInventory instance (if in_place=True) or a new TreeInventory instance (if in_place=False) with the completed inventory data.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the tree inventory does not complete within the specified timeout.</p> <code>NotFoundException</code> <p>If the tree inventory or domain no longer exists.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeInventory\n&gt;&gt;&gt; inventory = TreeInventory.from_domain_id(\"abc123\")\n</code></pre> <p>Basic usage with default parameters:</p> <pre><code>&gt;&gt;&gt; completed = inventory.wait_until_completed()\n&gt;&gt;&gt; print(completed.status)\n'completed'\n</code></pre> <p>With progress updates:</p> <pre><code>&gt;&gt;&gt; completed = inventory.wait_until_completed(\n...     step=10,\n...     timeout=1200,\n...     verbose=True\n... )\nTree inventory has status `pending` (10.00s)\nTree inventory has status `running` (20.00s)\nTree inventory has status `completed` (30.00s)\n</code></pre> <p>Without in-place updates:</p> <pre><code>&gt;&gt;&gt; completed = inventory.wait_until_completed(in_place=False)\n&gt;&gt;&gt; completed is inventory\nFalse\n</code></pre> Notes <ul> <li>Processing time varies based on domain size, data sources, modifications,   and treatments</li> <li>The method polls by calling get() at each interval, which counts against   API rate limits</li> <li>Consider longer step intervals for large domains or when making many   API calls</li> <li>For very large domains, you may need to increase the timeout beyond   the default 10 minutes</li> </ul>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this tree inventory.</p> <p>Permanently removes the tree inventory from the domain. This action: - Deletes the tree inventory data from the database - Cancels any ongoing processing jobs - Removes associated data from cache and cloud storage - Cannot be undone</p> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>NotFoundException</code> <p>If the tree inventory or domain no longer exists.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeInventory\n&gt;&gt;&gt; tree_inventory = TreeInventory.from_domain_id(\"abc123\")\n&gt;&gt;&gt; tree_inventory.delete()\n&gt;&gt;&gt; # The inventory is now permanently deleted\n&gt;&gt;&gt; tree_inventory.get()  # This will raise NotFoundException\n</code></pre> Notes <ul> <li>After deletion, any subsequent operations on this TreeInventory instance   will raise NotFoundException</li> <li>A new tree inventory can be created for the domain after deletion using   Domain.create_tree_inventory() or Domain.create_tree_inventory_from_treemap()</li> <li>Consider creating an export of important inventory data before deletion   using create_export()</li> </ul>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory.create_export","title":"create_export","text":"<pre><code>create_export(export_format: str) -&gt; Export\n</code></pre> <p>Create an export of the tree inventory data.</p> <p>Initiates an asynchronous process to export the tree inventory data into a specified file format. The export process runs in the background and generates a downloadable file once complete. Returns an Export object that provides methods for monitoring progress and downloading the result.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>The desired format for the exported data. Must be one of: - \"csv\": Comma-separated values format - \"parquet\": Apache Parquet format (efficient for large datasets) - \"geojson\": GeoJSON format (includes spatial information)</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object for managing the export process.</p> <p>Raises:</p> Type Description <code>ApiException</code> <p>If the tree inventory is not in \"completed\" status or if there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeInventory\n&gt;&gt;&gt; tree_inventory = TreeInventory.from_domain_id(\"abc123\")\n</code></pre> <p>Basic export with automatic filename:</p> <pre><code>&gt;&gt;&gt; tree_inventory.wait_until_completed()\n&gt;&gt;&gt; # Create and wait for export\n&gt;&gt;&gt; export = tree_inventory.create_export(\"csv\")\n&gt;&gt;&gt; export = export.wait_until_completed()\n&gt;&gt;&gt; # Download to current directory\n&gt;&gt;&gt; export.to_file(\"my/directory\")  # Creates 'inventories_tree.csv' in 'my/directory'\n</code></pre> <p>Export with custom filename and progress monitoring:</p> <pre><code>&gt;&gt;&gt; export = tree_inventory.create_export(\"parquet\")\n&gt;&gt;&gt; export = export.wait_until_completed(\n...     step=5,          # Check every 5 seconds\n...     timeout=300,     # Wait up to 5 minutes\n... )\n&gt;&gt;&gt; export.to_file(\"my_trees.parquet\")\n</code></pre> <p>Create multiple format exports:</p> <pre><code>&gt;&gt;&gt; # Create exports\n&gt;&gt;&gt; csv_export = tree_inventory.create_export(\"csv\")\n&gt;&gt;&gt; parquet_export = tree_inventory.create_export(\"parquet\")\n&gt;&gt;&gt; geojson_export = tree_inventory.create_export(\"geojson\")\n&gt;&gt;&gt; # Wait for all to complete\n&gt;&gt;&gt; for export in [csv_export, parquet_export, geojson_export]:\n...     export.wait_until_completed(in_place=True)\n&gt;&gt;&gt; # Download to a specific directory\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; output_dir = Path(\"exports\")\n&gt;&gt;&gt; output_dir.mkdir(exist_ok=True)\n&gt;&gt;&gt; for export in [csv_export, parquet_export, geojson_export]:\n...     export.to_file(output_dir)\n</code></pre> Notes <ul> <li>The tree inventory must be in \"completed\" status before creating an export</li> <li>Export generation is asynchronous and may take several seconds or minutes depending   on the data size</li> <li>Each format has specific advantages:</li> <li>CSV: Human-readable, compatible with most software</li> <li>Parquet: Efficient storage and querying for large datasets</li> <li>GeoJSON: Preserves spatial information, works with GIS software</li> <li>The Export object provides methods for monitoring and managing the export   process - use get() to check status, wait_until_completed() to wait for   completion, and to_file() to download</li> </ul>"},{"location":"reference/#fastfuels_sdk.inventories.TreeInventory.get_export","title":"get_export","text":"<pre><code>get_export(export_format: str) -&gt; Export\n</code></pre> <p>Retrieve the status of an existing export.</p> <p>Fetches the current state of a previously created export in the specified format. This method is commonly used to check if an export has completed and to get the download URL once it's ready.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>The format of the export to retrieve. Must be one of: - \"csv\": Comma-separated values format - \"parquet\": Apache Parquet format - \"geojson\": GeoJSON format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object representing the current state of the export.</p> <p>Raises:</p> Type Description <code>NotFoundException</code> <p>If no export exists for the specified format.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeInventory\n&gt;&gt;&gt; tree_inventory = TreeInventory.from_domain_id(\"abc123\")\n</code></pre> <p>Check export status:</p> <pre><code>&gt;&gt;&gt; export = tree_inventory.create_export(\"csv\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Check status later\n&gt;&gt;&gt; print(export.status)\n'completed'\n&gt;&gt;&gt; if export.status == \"completed\":\n...     export.to_file(\"trees.csv\")\n</code></pre> <p>Monitor export until complete:</p> <pre><code>&gt;&gt;&gt; from time import sleep\n&gt;&gt;&gt; export = tree_inventory.create_export(\"parquet\")\n&gt;&gt;&gt; export.wait_until_completed(in_place=True)\n&gt;&gt;&gt; export.to_file(\"trees.parquet\")\n</code></pre> Notes <ul> <li>This method only retrieves status; use create_export() to initiate a new export</li> <li>Export URLs expire after 7 days - you'll need to create a new export after   expiration</li> <li>The Export object's wait_until_completed() method provides a more   convenient way to wait for completion</li> <li>If you don't need the intermediate status checks, using   create_export().wait_until_completed() is simpler</li> <li>Always check the export's status before attempting to download using to_file()</li> </ul>"},{"location":"reference/#fastfuels_sdk.features","title":"fastfuels_sdk.features","text":"<p>fastfuels_sdk/features.py</p>"},{"location":"reference/#fastfuels_sdk.features.Features","title":"Features","text":"<p>               Bases: <code>Features</code></p> <p>Geographic features (roads and water bodies) associated with a domain.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>ID of the domain these features belong to</p> <code>road</code> <code>(RoadFeature, optional)</code> <p>Road network data</p> <code>water</code> <code>(WaterFeature, optional)</code> <p>Water body data</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Access road data\n&gt;&gt;&gt; if features.road:\n...     roads = features.road\n</code></pre> <pre><code>&gt;&gt;&gt; # Access water data\n&gt;&gt;&gt; if features.water:\n...     water = features.water\n</code></pre> <pre><code>&gt;&gt;&gt; # Get updated feature data\n&gt;&gt;&gt; features = features.get()\n</code></pre> See Also <p>Domain : Container for features RoadFeature : Road network structure WaterFeature : Water body structure</p>"},{"location":"reference/#fastfuels_sdk.features.Features.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; Features\n</code></pre> <p>Retrieve the features (roads and water bodies) associated with a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>The ID of the domain to retrieve features for</p> required <p>Returns:</p> Type Description <code>Features</code> <p>A Features object containing: - road : RoadFeature, optional     Road network data within the domain - water : WaterFeature, optional     Water bodies within the domain</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Check for specific features. These will be None until created.\n&gt;&gt;&gt; if features.road:\n...     print(\"Domain has road features\")\n&gt;&gt;&gt; if features.water:\n...     print(\"Domain has water features\")\n</code></pre> See Also <p>Features.get : Refresh feature data</p>"},{"location":"reference/#fastfuels_sdk.features.Features.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; Features\n</code></pre> <p>Get the latest feature data for this domain.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this Features instance with new data. If False (default), returns a new Features instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>Features</code> <p>The updated Features object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_features = features.get()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; features.get(in_place=True)\n</code></pre> See Also <p>Features.from_domain : Get features for a specific domain</p>"},{"location":"reference/#fastfuels_sdk.features.Features.create_road_feature","title":"create_road_feature","text":"<pre><code>create_road_feature(sources: str | List[str] | RoadFeatureSource | List[RoadFeatureSource], geojson: Optional[Union[Dict[str, Any], Geojson]] = None, in_place: bool = False) -&gt; RoadFeature\n</code></pre> <p>Create road features for this domain using specified data sources.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>str or list[str] or RoadFeatureSource or list[RoadFeatureSource]</code> <p>Data sources to use. Supports: - \"OSM\": OpenStreetMap data (not supported for local CRS domains) - \"geojson\": User-provided GeoJSON data (supported for all CRS including local)</p> required <code>geojson</code> <code>dict or Geojson</code> <p>GeoJSON Feature or FeatureCollection containing Polygon or MultiPolygon geometries. Required when source is \"geojson\".</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>If True, updates this Features instance with new data. If False (default), leaves this instance unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>RoadFeature</code> <p>The newly created road feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Create from OpenStreetMap\n&gt;&gt;&gt; road = features.create_road_feature(\"OSM\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create from GeoJSON\n&gt;&gt;&gt; geojson_data = {\n...     \"type\": \"FeatureCollection\",\n...     \"features\": [{\n...         \"type\": \"Feature\",\n...         \"geometry\": {\n...             \"type\": \"Polygon\",\n...             \"coordinates\": [[...]]\n...         }\n...     }]\n... }\n&gt;&gt;&gt; road = features.create_road_feature(\"geojson\", geojson=geojson_data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update Features instance\n&gt;&gt;&gt; features.create_road_feature(\"OSM\", in_place=True)\n&gt;&gt;&gt; features.road.status\n\"pending\"\n</code></pre> See Also <p>Features.create_road_feature_from_osm : Simpler method for OSM data Features.create_road_feature_from_geodataframe : Simpler method for GeoDataFrame data</p>"},{"location":"reference/#fastfuels_sdk.features.Features.create_road_feature_from_osm","title":"create_road_feature_from_osm","text":"<pre><code>create_road_feature_from_osm(in_place: bool = False) -&gt; RoadFeature\n</code></pre> <p>Create road features for this domain using OpenStreetMap data.</p> <p>This is a convenience method that provides a simpler interface for the common case of using OpenStreetMap as the data source.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this Features instance with new data. If False (default), leaves this instance unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>RoadFeature</code> <p>The newly created road feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Create new road features\n&gt;&gt;&gt; road = features.create_road_feature_from_osm()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update Features instance\n&gt;&gt;&gt; features.create_road_feature_from_osm(in_place=True)\n&gt;&gt;&gt; features.road.status\n\"pending\"\n</code></pre> See Also <p>Features.create_road_feature : More general method supporting multiple sources</p>"},{"location":"reference/#fastfuels_sdk.features.Features.create_road_feature_from_geodataframe","title":"create_road_feature_from_geodataframe","text":"<pre><code>create_road_feature_from_geodataframe(gdf, in_place: bool = False) -&gt; RoadFeature\n</code></pre> <p>Create road features for this domain from a GeoPandas GeoDataFrame.</p> <p>This convenience method accepts a GeoDataFrame and converts it to GeoJSON for road feature creation. Supports all coordinate systems including local CRS.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing Polygon or MultiPolygon geometries representing road areas. The geometries will be clipped to the domain boundary.</p> required <code>in_place</code> <code>bool</code> <p>If True, updates this Features instance with new data. If False (default), leaves this instance unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>RoadFeature</code> <p>The newly created road feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt;\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create GeoDataFrame with road polygons\n&gt;&gt;&gt; gdf = gpd.GeoDataFrame({\n...     'geometry': [Polygon([\n...         (-120.0, 39.0),\n...         (-120.0, 39.1),\n...         (-119.9, 39.1),\n...         (-119.9, 39.0),\n...         (-120.0, 39.0)\n...     ])]\n... }, crs=\"EPSG:4326\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create road features\n&gt;&gt;&gt; road = features.create_road_feature_from_geodataframe(gdf)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update Features instance\n&gt;&gt;&gt; features.create_road_feature_from_geodataframe(gdf, in_place=True)\n&gt;&gt;&gt; features.road.status\n\"pending\"\n</code></pre> See Also <p>Features.create_road_feature : More general method supporting multiple sources Features.create_road_feature_from_osm : Simpler method for OSM data</p>"},{"location":"reference/#fastfuels_sdk.features.Features.create_water_feature","title":"create_water_feature","text":"<pre><code>create_water_feature(sources: str | List[str] | WaterFeatureSource | List[WaterFeatureSource], in_place: bool = False) -&gt; WaterFeature\n</code></pre> <p>Create water features for this domain using specified data sources.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>str or list[str] or WaterFeatureSource or list[WaterFeatureSource]</code> <p>Data sources to use. Currently, supports: - \"OSM\": OpenStreetMap data</p> required <code>in_place</code> <code>bool</code> <p>If True, updates this Features instance with new data. If False (default), leaves this instance unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>WaterFeature</code> <p>The newly created water feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create from OpenStreetMap\n&gt;&gt;&gt; water = features.create_water_feature(\"OSM\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update Features instance\n&gt;&gt;&gt; features.create_water_feature(\"OSM\", in_place=True)\n&gt;&gt;&gt; features.water.status\n\"pending\"\n</code></pre> See Also <p>Features.create_water_feature_from_osm : Simpler method for OSM data</p>"},{"location":"reference/#fastfuels_sdk.features.Features.create_water_feature_from_osm","title":"create_water_feature_from_osm","text":"<pre><code>create_water_feature_from_osm(in_place: bool = False) -&gt; WaterFeature\n</code></pre> <p>Create water features for this domain using OpenStreetMap data.</p> <p>This is a convenience method that provides a simpler interface for the common case of using OpenStreetMap as the data source.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this Features instance with new data. If False (default), leaves this instance unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>WaterFeature</code> <p>The newly created water feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create new water features\n&gt;&gt;&gt; water = features.create_water_feature_from_osm()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update Features instance with new water feature\n&gt;&gt;&gt; features.create_water_feature_from_osm(in_place=True)\n&gt;&gt;&gt; features.water.status\n\"pending\"\n</code></pre> See Also <p>Features.create_water_feature : More general method supporting multiple sources</p>"},{"location":"reference/#fastfuels_sdk.features.RoadFeature","title":"RoadFeature","text":"<p>               Bases: <code>RoadFeature</code></p> <p>Road network features within a domain's spatial boundaries.</p> <p>Represents road features extracted from various data sources (OpenStreetMap or user-provided GeoJSON/GeoDataFrame). Road features include information about road locations, types, and attributes.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>ID of the domain these roads belong to</p> <code>sources</code> <code>list[RoadFeatureSource]</code> <p>Data sources used to create these features (\"OSM\" or \"geojson\")</p> <code>geojson</code> <code>(Geojson, optional)</code> <p>GeoJSON data if created from geojson source</p> <code>status</code> <code>(str, optional)</code> <p>Current processing status (\"pending\", \"running\", \"completed\")</p> <code>created_on</code> <code>(datetime, optional)</code> <p>When these features were created</p> <code>modified_on</code> <code>(datetime, optional)</code> <p>When these features were last modified</p> <code>checksum</code> <code>(str, optional)</code> <p>Unique identifier for this version of the features</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk.features import Features\nGet existing road features:\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; if features.road:\n...     road_features = features.road\n</code></pre> <p>Create road features from OpenStreetMap:</p> <pre><code>&gt;&gt;&gt; road_features = features.create_road_feature(\"OSM\")\n&gt;&gt;&gt; print(road_features.status)\n'pending'\n</code></pre> <p>Create road features from GeoDataFrame:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; gdf = gpd.read_file(\"roads.geojson\")\n&gt;&gt;&gt; road_features = features.create_road_feature_from_geodataframe(gdf)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.RoadFeature.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; RoadFeature\n</code></pre> <p>Get the latest road feature data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this RoadFeature instance with new data. If False (default), returns a new RoadFeature instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>RoadFeature</code> <p>The updated road feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; road = features.create_road_feature(\"OSM\")\n&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_road = road.get()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; road.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.RoadFeature.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; RoadFeature\n</code></pre> <p>Wait for road feature processing to complete.</p> <p>Road features are processed asynchronously and may take several seconds to minutes to complete depending on domain size and data sources.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Seconds between status checks (default: 5)</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum seconds to wait (default: 600)</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates this instance with completed data. If False, returns a new instance.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>RoadFeature</code> <p>The completed road feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; road = features.create_road_feature(\"OSM\")\n&gt;&gt;&gt; road.wait_until_completed(verbose=True)\nRoad features have status `pending` (5.00s)\nRoad features have status `completed` (10.00s)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.RoadFeature.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete these road features.</p> <p>Permanently removes road feature data from the domain. This also cancels any ongoing processing jobs.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; road = features.create_road_feature(\"OSM\")\n&gt;&gt;&gt; # Remove road features when no longer needed\n&gt;&gt;&gt; road.delete()\n&gt;&gt;&gt; # Subsequent operations will raise NotFoundException\n&gt;&gt;&gt; road.get()  # raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.WaterFeature","title":"WaterFeature","text":"<p>               Bases: <code>WaterFeature</code></p> <p>Water body features within a domain's spatial boundaries.</p> <p>Represents water features extracted from various data sources (like OpenStreetMap) within a domain. Water features include information about water body locations, types, and attributes.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>ID of the domain these water bodies belong to</p> <code>sources</code> <code>list[WaterFeatureSource]</code> <p>Data sources used to create these features</p> <code>status</code> <code>(str, optional)</code> <p>Current processing status (\"pending\", \"running\", \"completed\")</p> <code>created_on</code> <code>(datetime, optional)</code> <p>When these features were created</p> <code>modified_on</code> <code>(datetime, optional)</code> <p>When these features were last modified</p> <code>checksum</code> <code>(str, optional)</code> <p>Unique identifier for this version of the features</p> <p>Examples:</p> <p>Get existing water features:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; if features.water:\n...     water_features = features.water\n</code></pre> <p>Create new water features:</p> <pre><code>&gt;&gt;&gt; water_features = features.create_water_feature(\"OSM\")\n&gt;&gt;&gt; print(water_features.status)\n'pending'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.WaterFeature.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; WaterFeature\n</code></pre> <p>Get the latest water feature data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this WaterFeature instance with new data. If False (default), returns a new WaterFeature instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>WaterFeature</code> <p>The updated water feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; water = features.create_water_feature(\"OSM\")\n&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_water = water.get()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; water.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.WaterFeature.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; WaterFeature\n</code></pre> <p>Wait for water feature processing to complete.</p> <p>Water features are processed asynchronously and may take several seconds to minutes to complete depending on domain size and data sources.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Seconds between status checks (default: 5)</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum seconds to wait (default: 600)</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates this instance with completed data. If False, returns a new instance.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>WaterFeature</code> <p>The completed water feature object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; water = features.create_water_feature(\"OSM\")\n&gt;&gt;&gt; water.wait_until_completed(verbose=True)\nWater features have status `pending` (5.00s)\nWater features have status `completed` (10.00s)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.features.WaterFeature.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete these water features.</p> <p>Permanently removes water feature data from the domain. This also cancels any ongoing processing jobs.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Features\n&gt;&gt;&gt; features = Features.from_domain_id(\"abc123\")\n&gt;&gt;&gt; water = features.create_water_feature(\"OSM\")\n&gt;&gt;&gt; # Remove water features when no longer needed\n&gt;&gt;&gt; water.delete()\n&gt;&gt;&gt; # Subsequent operations will raise NotFoundException\n&gt;&gt;&gt; water.get()  # raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids","title":"fastfuels_sdk.grids","text":""},{"location":"reference/#fastfuels_sdk.grids.Grids","title":"Grids","text":"<p>               Bases: <code>Grids</code></p> <p>Container for different types of gridded data within a domain's spatial boundaries.</p> <p>A Grids object provides access to various types of gridded data (tree, surface, topography, and feature) associated with a specific domain. Each grid type represents different aspects of the landscape and can be exported in different formats for use in fire behavior modeling.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>ID of the domain these grids belong to</p> <code>tree</code> <code>(TreeGrid, optional)</code> <p>3D tree canopy data</p> <code>surface</code> <code>(SurfaceGrid, optional)</code> <p>Surface fuel data</p> <code>topography</code> <code>(TopographyGrid, optional)</code> <p>Elevation and terrain data</p> <code>feature</code> <code>(FeatureGrid, optional)</code> <p>Road, water, and other geographic features</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Grids\n&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Access specific grid types\n&gt;&gt;&gt; if grids.tree:\n...     print(\"Domain has tree grid data\")\n&gt;&gt;&gt; if grids.surface:\n...     print(\"Domain has surface fuel data\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Export grids to QUIC-Fire format\n&gt;&gt;&gt; export = grids.create_export(\"QUIC-Fire\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zip\")\n</code></pre> See Also <p>Domain : Spatial container for grids TreeGrid : 3D canopy structure SurfaceGrid : Surface fuel properties TopographyGrid : Elevation data FeatureGrid : Geographic features</p>"},{"location":"reference/#fastfuels_sdk.grids.Grids.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; Grids\n</code></pre> <p>Retrieve the grids associated with a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>The ID of the domain to retrieve grids for</p> required <p>Returns:</p> Type Description <code>Grids</code> <p>The grid data for the domain</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Check for specific grid types\n&gt;&gt;&gt; if grids.tree:\n...     print(\"Domain has tree grid data\")\n&gt;&gt;&gt; if grids.surface:\n...     print(\"Domain has surface grid data\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.Grids.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; Grids\n</code></pre> <p>Get the latest grid data for this domain.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this Grids instance with new data. If False (default), returns a new Grids instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>Grids</code> <p>The updated Grids object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_grids = grids.get()\n</code></pre> <pre><code>&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; grids.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.Grids.create_surface_grid","title":"create_surface_grid","text":"<pre><code>create_surface_grid(attributes: List[str], fuel_load: Optional[dict] = None, fuel_depth: Optional[dict] = None, fuel_moisture: Optional[dict] = None, savr: Optional[dict] = None, fbfm: Optional[dict] = None, modifications: Optional[dict | list[dict]] = None, in_place: bool = False) -&gt; SurfaceGrid\n</code></pre> <p>Create a surface grid for the current domain.</p> <p>Creates a surface grid containing various fuel and vegetation attributes within the spatial context of your domain. While this method provides direct creation capability, consider using SurfaceGridBuilder for more complex configurations and better parameter validation.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>List[str]</code> <p>List of attributes to include in the grid. Available attributes: - \"fuelLoad\": Surface fuel loading - \"fuelDepth\": Depth of surface fuels - \"fuelMoisture\": Moisture content of fuels - \"SAVR\": Surface area to volume ratio - \"FBFM\": Fire Behavior Fuel Model</p> required <code>fuel_load</code> <code>dict</code> <p>Configuration for fuel load attribute. See SurfaceGridBuilder for details.</p> <code>None</code> <code>fuel_depth</code> <code>dict</code> <p>Configuration for fuel depth attribute. See SurfaceGridBuilder for details.</p> <code>None</code> <code>fuel_moisture</code> <code>dict</code> <p>Configuration for fuel moisture content. See SurfaceGridBuilder for details.</p> <code>None</code> <code>savr</code> <code>dict</code> <p>Configuration for surface area to volume ratio. See SurfaceGridBuilder for details.</p> <code>None</code> <code>fbfm</code> <code>dict</code> <p>Configuration for Fire Behavior Fuel Model. See SurfaceGridBuilder for details.</p> <code>None</code> <code>modifications</code> <code>dict or list[dict]</code> <p>Rules for modifying grid attributes. See SurfaceGridBuilder for details.</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>If True, updates this object's surface grid (self.surface). If False (default), leaves this object unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>SurfaceGrid</code> <p>The newly created surface grid object.</p> Notes <p>Grid generation happens asynchronously. The returned grid will initially have a \"pending\" status.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Grids\n&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <p>Simple usage with uniform values:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_surface_grid(\n...     attributes=[\"fuelLoad\", \"fuelMoisture\"],\n...     fuel_load={\"source\": \"uniform\", \"value\": 0.5},\n...     fuel_moisture={\"source\": \"uniform\", \"value\": 0.1}\n... )\n</code></pre> See Also <p>SurfaceGridBuilder : Helper class for creating complex surface grid configurations     with parameter validation and a fluent interface.</p>"},{"location":"reference/#fastfuels_sdk.grids.Grids.create_topography_grid","title":"create_topography_grid","text":"<pre><code>create_topography_grid(attributes: List[str], elevation: Optional[dict] = None, slope: Optional[dict] = None, aspect: Optional[dict] = None, in_place: bool = False) -&gt; TopographyGrid\n</code></pre> <p>Create a topography grid for the current domain.</p> <p>Creates a topography grid containing elevation, slope, and/or aspect data within the spatial context of your domain.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>List[str]</code> <p>List of attributes to include in the grid. Available attributes: - \"elevation\": Terrain elevation above sea level - \"slope\": Slope of terrain surface - \"aspect\": Direction the slope faces</p> required <code>elevation</code> <code>dict</code> <p>Configuration for elevation attribute. Sources available: - 3DEP (default):     {         \"source\": \"3DEP\",         \"interpolationMethod\": \"cubic\"  # or \"nearest\", \"linear\"     } - LANDFIRE:     {         \"source\": \"LANDFIRE\",         \"version\": \"2020\",         \"interpolationMethod\": \"cubic\"  # or \"nearest\", \"linear\", \"zipper\"     } - Uniform:     {         \"source\": \"uniform\",         \"value\": float  # elevation in meters     }</p> <code>None</code> <code>slope</code> <code>dict</code> <p>Configuration for slope attribute. Sources available: - 3DEP (default):     {         \"source\": \"3DEP\",         \"interpolationMethod\": \"cubic\"  # or \"nearest\", \"linear\"     } - LANDFIRE:     {         \"source\": \"LANDFIRE\",         \"version\": \"2020\",         \"interpolationMethod\": \"cubic\"  # or \"nearest\", \"linear\", \"zipper\"     }</p> <code>None</code> <code>aspect</code> <code>dict</code> <p>Configuration for aspect attribute. Sources available: - 3DEP (default):     {         \"source\": \"3DEP\",         \"interpolationMethod\": \"nearest\"     } - LANDFIRE:     {         \"source\": \"LANDFIRE\",         \"version\": \"2020\",         \"interpolationMethod\": \"nearest\"     }</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>If True, updates this object's topography grid (self.topography). If False (default), leaves this object unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>TopographyGrid</code> <p>The newly created topography grid object.</p> Notes <p>Grid generation happens asynchronously. The returned grid will initially have a \"pending\" status.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Grids\n&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <p>Simple usage with default 3DEP source:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_topography_grid(\n...     attributes=[\"elevation\", \"slope\"]\n... )\n</code></pre> <p>Using multiple data sources:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_topography_grid(\n...     attributes=[\"elevation\", \"slope\", \"aspect\"],\n...     elevation={\n...         \"source\": \"LANDFIRE\",\n...         \"version\": \"2020\",\n...         \"interpolationMethod\": \"cubic\"\n...     },\n...     slope={\n...         \"source\": \"3DEP\",\n...         \"interpolationMethod\": \"cubic\"\n...     }\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.Grids.create_tree_grid","title":"create_tree_grid","text":"<pre><code>create_tree_grid(attributes: List[str], bulk_density: Optional[dict] = None, spcd: Optional[dict] = None, fuel_moisture: Optional[dict] = None, savr: Optional[dict] = None, in_place: bool = False) -&gt; TreeGrid\n</code></pre> <p>Create a tree grid for the current domain.</p> <p>Creates a tree grid containing canopy bulk density, species codes, and/or fuel moisture data within the spatial context of your domain. While this method provides direct creation capability, consider using TreeGridBuilder for more complex configurations and better parameter validation.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>List[str]</code> <p>List of attributes to include in the grid. Available attributes: - \"bulkDensity\": Canopy bulk density - \"SPCD\": Species code - \"fuelMoisture\": Moisture content - \"SAVR\": Surface area to volume ratio</p> required <code>bulk_density</code> <code>dict</code> <p>Configuration for bulk density attribute. Sources available: - Inventory:     {         \"source\": \"inventory\"     } - Uniform:     {         \"source\": \"uniform\",         \"value\": float  # bulk density in kg/m\u00b3     }</p> <code>None</code> <code>spcd</code> <code>dict</code> <p>Configuration for species code attribute. Sources available: - Inventory:     {         \"source\": \"inventory\"     } - Uniform:     {         \"source\": \"uniform\",         \"value\": str  # species code     }</p> <code>None</code> <code>fuel_moisture</code> <code>dict</code> <p>Configuration for fuel moisture content. Only supports uniform values: {     \"source\": \"uniform\",     \"value\": float  # moisture content in % }</p> <code>None</code> <code>SAVR</code> <p>Configuration for surface area to volume ratio. Sources available: - Inventory:     {         \"source\": \"inventory\"     } - Uniform:     {         \"source\": \"uniform\",         \"value\": str  # surface area to volume ratio in m\u00b2/m\u00b3     }</p> required <code>in_place</code> <code>bool</code> <p>If True, updates this object's tree grid (self.tree). If False (default), leaves this object unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeGrid</code> <p>The newly created tree grid object.</p> Notes <p>Grid generation happens asynchronously. The returned grid will initially have a \"pending\" status.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Grids\n&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <p>Simple usage with uniform values:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_tree_grid(\n...     attributes=[\"bulkDensity\", \"fuelMoisture\"],\n...     bulk_density={\"source\": \"uniform\", \"value\": 0.5},\n...     fuel_moisture={\"source\": \"uniform\", \"value\": 15.0}\n... )\n</code></pre> <p>Using inventory data:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_tree_grid(\n...     attributes=[\"bulkDensity\", \"SPCD\"],\n...     bulk_density={\"source\": \"inventory\"},\n...     spcd={\"source\": \"inventory\"}\n... )\n</code></pre> See Also <p>TreeGridBuilder : Helper class for creating complex tree grid configurations     with parameter validation and a fluent interface.</p>"},{"location":"reference/#fastfuels_sdk.grids.Grids.create_feature_grid","title":"create_feature_grid","text":"<pre><code>create_feature_grid(attributes: List[str], in_place: bool = False) -&gt; FeatureGrid\n</code></pre> <p>Create a feature grid for the current domain.</p> <p>Creates a feature grid containing various geographic features within the spatial context of your domain. Feature grids represent spatial data related to various features such as roads, water bodies, and other geographic elements.</p> <p>Feature resources must have a \"completed\" status before they can be included as attributes to a feature grid.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>List[str]</code> <p>List of feature types to rasterize in the grid. Available attributes depend on the specific geographic features in your domain area.</p> required <code>in_place</code> <code>bool</code> <p>If True, updates this object's feature grid (self.feature). If False (default), leaves this object unchanged.</p> <code>False</code> <p>Returns:</p> Type Description <code>FeatureGrid</code> <p>The newly created feature grid object.</p> Notes <p>Grid generation happens asynchronously. The returned grid will initially have a \"pending\" status.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Grids\n&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <p>Simple usage with specific feature types:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_feature_grid(\n...     attributes=[\"road\", \"water\"]\n... )\n</code></pre> <p>Create and wait for completion:</p> <pre><code>&gt;&gt;&gt; grid = grids.create_feature_grid(\n...     attributes=[\"road\", \"water\"],\n...     in_place=True\n... )\n&gt;&gt;&gt; grid.wait_until_completed()\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.Grids.create_export","title":"create_export","text":"<pre><code>create_export(export_format: str) -&gt; Export\n</code></pre> <p>Create an export of the grid data.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format to export the data in. Must be one of: - \"zarr\": Compressed array format - \"QUIC-Fire\": Input files for QUIC-Fire model</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object for managing the export process.</p> Notes <p>The QUIC-Fire format creates a zip file with:     - treesrhof.dat: Bulk density data     - treesmoist.dat: Moisture content data     - treesdepth.dat: Canopy depth data     - topo.dat: Topography data (if available)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; export = grids.create_export(\"QUIC-Fire\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zip\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.Grids.get_export","title":"get_export","text":"<pre><code>get_export(export_format: str) -&gt; Export\n</code></pre> <p>Get the status of an existing export.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format of the export to check. Must be one of: - \"zarr\": Compressed array format - \"QUIC-Fire\": Input files for QUIC-Fire model</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object containing current status.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import Grids\n&gt;&gt;&gt; grids = Grids.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = grids.create_export(\"zarr\")\n&gt;&gt;&gt; # Check status later\n&gt;&gt;&gt; updated_export = grids.get_export(\"zarr\")\n&gt;&gt;&gt; if export.status == \"completed\":\n...     export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid","title":"TreeGrid","text":"<p>               Bases: <code>TreeGrid</code></p> <p>Tree grid data within a domain's spatial boundaries.</p>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; TreeGrid\n</code></pre> <p>Retrieve an existing tree grid for a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>ID of the domain to retrieve tree grid for</p> required <p>Returns:</p> Type Description <code>TreeGrid</code> <p>The tree grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tree_grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; tree_grid.status\n'completed'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; TreeGrid\n</code></pre> <p>Get the latest tree grid data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this TreeGrid instance with new data. If False (default), returns a new TreeGrid instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeGrid</code> <p>The updated tree grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeGrid\n&gt;&gt;&gt; tree_grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_grid = tree_grid.get()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; tree_grid.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; 'TreeGrid'\n</code></pre> <p>Wait for the tree grid processing to complete.</p> <p>Tree grids are processed asynchronously and may take between several seconds to minutes to complete depending on domain size and complexity. This method polls the API at regular intervals until the grid reaches a 'completed' status or the timeout is reached.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Number of seconds to wait between status checks. Default is 5 seconds. Use larger values to reduce API calls, smaller values for more frequent updates.</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum number of seconds to wait for completion. Default is 600 seconds (10 minutes). If the timeout is reached before completion, raises a TimeoutError.</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates the current TreeGrid instance with new data at each check. If False, leaves the current instance unchanged and returns a new instance when complete.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates at each check. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TreeGrid</code> <p>Either the current TreeGrid instance (if in_place=True) or a new TreeGrid instance (if in_place=False) with the completed grid data.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the tree grid does not complete within the specified timeout.</p> <code>NotFoundException</code> <p>If the tree grid or domain no longer exists.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <p>Basic usage with default parameters: from fastfuels_sdk import TreeGrid</p> <pre><code>&gt;&gt;&gt; grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; completed = grid.wait_until_completed()\n&gt;&gt;&gt; print(completed.status)\n'completed'\n</code></pre> <p>With progress updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(\n...     step=10,\n...     timeout=1200,\n...     verbose=True\n... )\nTree grid has status `pending` (10.00s)\nTree grid has status `running` (20.00s)\nTree grid has status `completed` (30.00s)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.get_attributes","title":"get_attributes","text":"<pre><code>get_attributes() -&gt; GridAttributeMetadataResponse\n</code></pre> <p>Get metadata about grid attributes.</p> <p>Returns metadata about the structure of the tree grid and its attributes, including dimensions, chunking, and attribute details.</p> <p>Returns:</p> Type Description <code>GridAttributeMetadataResponse</code> <p>Metadata about grid structure and attributes including: - shape: Dimensions of the grid data - dimensions: Names of each dimension - chunks: Number of chunks in each dimension - chunk_shape: Shape of each chunk - attributes: Detailed information about each attribute</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeGrid\n&gt;&gt;&gt; tree_grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; metadata = tree_grid.get_attributes()\n&gt;&gt;&gt; print(metadata.shape)\n[100, 100, 50]\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.create_export","title":"create_export","text":"<pre><code>create_export(export_format: str) -&gt; Export\n</code></pre> <p>Create an export of the tree grid data.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format for the export. Must be one of: - \"zarr\": Compressed array format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object for managing the export process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeGrid\n&gt;&gt;&gt; tree_grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = tree_grid.create_export(\"zarr\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.get_export","title":"get_export","text":"<pre><code>get_export(export_format: str) -&gt; Export\n</code></pre> <p>Get the status of an existing export.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format of the export to check. Must be one of: - \"zarr\": Compressed array format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object containing current status</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeGrid\n&gt;&gt;&gt; tree_grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = tree_grid.create_export(\"zarr\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGrid.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this tree grid.</p> <p>Permanently removes tree grid data from the domain. This also cancels any ongoing processing jobs.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TreeGrid\n&gt;&gt;&gt; tree_grid = TreeGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Remove grid when no longer needed\n&gt;&gt;&gt; tree_grid.delete()\n&gt;&gt;&gt; # Subsequent operations will raise NotFoundException\n&gt;&gt;&gt; tree_grid.get()  # raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.FeatureGrid","title":"FeatureGrid","text":"<p>               Bases: <code>FeatureGrid</code></p> <p>Feature grid data within a domain's spatial boundaries.</p>"},{"location":"reference/#fastfuels_sdk.grids.FeatureGrid.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; 'FeatureGrid'\n</code></pre> <p>Retrieve an existing feature grid for a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>ID of the domain to retrieve feature grid for</p> required <p>Returns:</p> Type Description <code>FeatureGrid</code> <p>The feature grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grid = FeatureGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; print(grid.status)\n'completed'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.FeatureGrid.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; 'FeatureGrid'\n</code></pre> <p>Get the latest feature grid data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this FeatureGrid instance with new data. If False (default), returns a new FeatureGrid instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>FeatureGrid</code> <p>The updated feature grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import FeatureGrid\n&gt;&gt;&gt; grid = FeatureGrid.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_grid = grid.get()\n</code></pre> <pre><code>&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; grid.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.FeatureGrid.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; 'FeatureGrid'\n</code></pre> <p>Wait for the feature grid processing to complete.</p> <p>Feature grids are processed asynchronously and may take between several seconds to minutes to complete depending on domain size and complexity. This method polls the API at regular intervals until the grid reaches a 'completed' status or the timeout is reached.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Number of seconds to wait between status checks. Default is 5 seconds. Use larger values to reduce API calls, smaller values for more frequent updates.</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum number of seconds to wait for completion. Default is 600 seconds (10 minutes). If the timeout is reached before completion, raises a TimeoutError.</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates the current FeatureGrid instance with new data at each check. If False, leaves the current instance unchanged and returns a new instance when complete.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates at each check. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>FeatureGrid</code> <p>Either the current FeatureGrid instance (if in_place=True) or a new FeatureGrid instance (if in_place=False) with the completed grid data.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the feature grid does not complete within the specified timeout.</p> <code>NotFoundException</code> <p>If the feature grid or domain no longer exists.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import FeatureGrid\n&gt;&gt;&gt; grid = FeatureGrid.from_domain_id(\"abc123\")\n</code></pre> <p>Basic usage with default parameters:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed()\n&gt;&gt;&gt; print(completed.status)\n'completed'\n</code></pre> <p>With progress updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(\n...     step=10,\n...     timeout=1200,\n...     verbose=True\n... )\nFeature grid has status `pending` (10.00s)\nFeature grid has status `running` (20.00s)\nFeature grid has status `completed` (30.00s)\n</code></pre> <p>Without in-place updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(in_place=False)\n&gt;&gt;&gt; completed is grid\nFalse\n</code></pre> Notes <ul> <li>Processing time varies based on domain size and grid configuration</li> <li>The method polls by calling get() at each interval, which counts against API rate limits</li> <li>Consider longer step intervals for large domains or when making many API calls</li> <li>For very large domains, you may need to increase the timeout beyond the default 10 minutes</li> </ul>"},{"location":"reference/#fastfuels_sdk.grids.FeatureGrid.get_attributes","title":"get_attributes","text":"<pre><code>get_attributes() -&gt; GridAttributeMetadataResponse\n</code></pre> <p>Get metadata about grid attributes.</p> <p>Returns metadata about the structure of the feature grid and its attributes, including dimensions, chunking, and attribute details.</p> <p>Returns:</p> Type Description <code>GridAttributeMetadataResponse</code> <p>Metadata about grid structure and attributes including: - shape: Dimensions of the grid data - dimensions: Names of each dimension - chunks: Number of chunks in each dimension - chunk_shape: Shape of each chunk - attributes: Detailed information about each attribute</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import FeatureGrid\n&gt;&gt;&gt; grid = FeatureGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; metadata = grid.get_attributes()\n&gt;&gt;&gt; print(metadata.shape)\n[100, 100, 50]\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.FeatureGrid.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this feature grid.</p> <p>Permanently removes feature grid data from the domain. This also cancels any ongoing processing jobs.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import FeatureGrid\n&gt;&gt;&gt; grid = FeatureGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Remove grid when no longer needed\n&gt;&gt;&gt; grid.delete()\n&gt;&gt;&gt; # Subsequent operations will raise NotFoundException\n&gt;&gt;&gt; grid.get()  # raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid","title":"SurfaceGrid","text":"<p>               Bases: <code>SurfaceGrid</code></p> <p>Surface grid data within a domain's spatial boundaries.</p>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; 'SurfaceGrid'\n</code></pre> <p>Retrieve an existing surface grid for a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>ID of the domain to retrieve surface grid for</p> required <p>Returns:</p> Type Description <code>SurfaceGrid</code> <p>The surface grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; print(grid.status)\n'completed'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; 'SurfaceGrid'\n</code></pre> <p>Get the latest surface grid data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this SurfaceGrid instance with new data. If False (default), returns a new SurfaceGrid instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>SurfaceGrid</code> <p>The updated surface grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import SurfaceGrid\n&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_grid = grid.get()\n</code></pre> <pre><code>&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; grid.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; 'SurfaceGrid'\n</code></pre> <p>Wait for the surface grid processing to complete.</p> <p>Surface grids are processed asynchronously and may take between several seconds to minutes to complete depending on domain size and complexity. This method polls the API at regular intervals until the grid reaches a 'completed' status or the timeout is reached.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Number of seconds to wait between status checks. Default is 5 seconds. Use larger values to reduce API calls, smaller values for more frequent updates.</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum number of seconds to wait for completion. Default is 600 seconds (10 minutes). If the timeout is reached before completion, raises a TimeoutError.</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates the current SurfaceGrid instance with new data at each check. If False, leaves the current instance unchanged and returns a new instance when complete.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates at each check. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>SurfaceGrid</code> <p>Either the current SurfaceGrid instance (if in_place=True) or a new SurfaceGrid instance (if in_place=False) with the completed grid data.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the surface grid does not complete within the specified timeout.</p> <code>NotFoundException</code> <p>If the surface grid or domain no longer exists.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import SurfaceGrid\n&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n</code></pre> <p>Basic usage with default parameters:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed()\n&gt;&gt;&gt; print(completed.status)\n'completed'\n</code></pre> <p>With progress updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(\n...     step=10,\n...     timeout=1200,\n...     verbose=True\n... )\nSurface grid has status `pending` (10.00s)\nSurface grid has status `running` (20.00s)\nSurface grid has status `completed` (30.00s)\n</code></pre> <p>Without in-place updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(in_place=False)\n&gt;&gt;&gt; completed is grid\nFalse\n</code></pre> Notes <ul> <li>Processing time varies based on domain size and grid configuration</li> <li>The method polls by calling get() at each interval, which counts against API rate limits</li> <li>Consider longer step intervals for large domains or when making many API calls</li> <li>For very large domains, you may need to increase the timeout beyond the default 10 minutes</li> </ul>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.get_attributes","title":"get_attributes","text":"<pre><code>get_attributes() -&gt; GridAttributeMetadataResponse\n</code></pre> <p>Get metadata about grid attributes.</p> <p>Returns metadata about the structure of the surface grid and its attributes, including dimensions, chunking, and attribute details.</p> <p>Returns:</p> Type Description <code>GridAttributeMetadataResponse</code> <p>Metadata about grid structure and attributes including: - shape: Dimensions of the grid data - dimensions: Names of each dimension - chunks: Number of chunks in each dimension - chunk_shape: Shape of each chunk - attributes: Detailed information about each attribute</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import SurfaceGrid\n&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; metadata = grid.get_attributes()\n&gt;&gt;&gt; print(metadata.shape)\n[100, 100, 50]\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.create_export","title":"create_export","text":"<pre><code>create_export(export_format: str) -&gt; Export\n</code></pre> <p>Create an export of the surface grid data.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format for the export. Must be one of: - \"zarr\": Compressed array format - \"geotiff\": GeoTIFF format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object for managing the export process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import SurfaceGrid\n&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = grid.create_export(\"zarr\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.get_export","title":"get_export","text":"<pre><code>get_export(export_format: str) -&gt; Export\n</code></pre> <p>Get the status of an existing export.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format of the export to check. Must be one of: - \"zarr\": Compressed array format - \"geotiff\": GeoTIFF format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object containing current status</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import SurfaceGrid\n&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = grid.create_export(\"zarr\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGrid.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this surface grid.</p> <p>Permanently removes surface grid data from the domain. This also cancels any ongoing processing jobs.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import SurfaceGrid\n&gt;&gt;&gt; grid = SurfaceGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Remove grid when no longer needed\n&gt;&gt;&gt; grid.delete()\n&gt;&gt;&gt; # Subsequent operations will raise NotFoundException\n&gt;&gt;&gt; grid.get()  # raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid","title":"TopographyGrid","text":"<p>               Bases: <code>TopographyGrid</code></p> <p>Topography grid data within a domain's spatial boundaries.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.from_domain_id","title":"from_domain_id  <code>classmethod</code>","text":"<pre><code>from_domain_id(domain_id: str) -&gt; 'TopographyGrid'\n</code></pre> <p>Retrieve an existing topography grid for a domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>str</code> <p>ID of the domain to retrieve topography grid for</p> required <p>Returns:</p> Type Description <code>TopographyGrid</code> <p>The topography grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; print(grid.status)\n'completed'\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; 'TopographyGrid'\n</code></pre> <p>Get the latest topography grid data.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates this TopographyGrid instance with new data. If False (default), returns a new TopographyGrid instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>TopographyGrid</code> <p>The updated topography grid object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TopographyGrid\n&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Get fresh data in a new instance\n&gt;&gt;&gt; updated_grid = grid.get()\n</code></pre> <pre><code>&gt;&gt;&gt; # Or update the existing instance\n&gt;&gt;&gt; grid.get(in_place=True)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; 'TopographyGrid'\n</code></pre> <p>Wait for the topography grid processing to complete.</p> <p>Topography grids are processed asynchronously and may take between several seconds to minutes to complete depending on domain size and complexity. This method polls the API at regular intervals until the grid reaches a 'completed' status or the timeout is reached.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Number of seconds to wait between status checks. Default is 5 seconds. Use larger values to reduce API calls, smaller values for more frequent updates.</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum number of seconds to wait for completion. Default is 600 seconds (10 minutes). If the timeout is reached before completion, raises a TimeoutError.</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True (default), updates the current TopographyGrid instance with new data at each check. If False, leaves the current instance unchanged and returns a new instance when complete.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates at each check. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>TopographyGrid</code> <p>Either the current TopographyGrid instance (if in_place=True) or a new TopographyGrid instance (if in_place=False) with the completed grid data.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the topography grid does not complete within the specified timeout.</p> <code>NotFoundException</code> <p>If the topography grid or domain no longer exists.</p> <code>ApiException</code> <p>If there is an error communicating with the API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TopographyGrid\n&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n</code></pre> <p>Basic usage with default parameters:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed()\n&gt;&gt;&gt; print(completed.status)\n'completed'\n</code></pre> <p>With progress updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(\n...     step=10,\n...     timeout=1200,\n...     verbose=True\n... )\nTopography grid has status `pending` (10.00s)\nTopography grid has status `running` (20.00s)\nTopography grid has status `completed` (30.00s)\n</code></pre> <p>Without in-place updates:</p> <pre><code>&gt;&gt;&gt; completed = grid.wait_until_completed(in_place=False)\n&gt;&gt;&gt; completed is grid\nFalse\n</code></pre> Notes <ul> <li>Processing time varies based on domain size and grid configuration</li> <li>The method polls by calling get() at each interval, which counts against API rate limits</li> <li>Consider longer step intervals for large domains or when making many API calls</li> <li>For very large domains, you may need to increase the timeout beyond the default 10 minutes</li> </ul>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.get_attributes","title":"get_attributes","text":"<pre><code>get_attributes() -&gt; GridAttributeMetadataResponse\n</code></pre> <p>Get metadata about grid attributes.</p> <p>Returns metadata about the structure of the topography grid and its attributes, including dimensions, chunking, and attribute details.</p> <p>Returns:</p> Type Description <code>GridAttributeMetadataResponse</code> <p>Metadata about grid structure and attributes including: - shape: Dimensions of the grid data - dimensions: Names of each dimension - chunks: Number of chunks in each dimension - chunk_shape: Shape of each chunk - attributes: Detailed information about each attribute</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TopographyGrid\n&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; metadata = grid.get_attributes()\n&gt;&gt;&gt; print(metadata.shape)\n[100, 100, 50]\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.create_export","title":"create_export","text":"<pre><code>create_export(export_format: str) -&gt; Export\n</code></pre> <p>Create an export of the topography grid data.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format for the export. Must be one of: - \"zarr\": Compressed array format - \"geotiff\": GeoTIFF format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object for managing the export process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TopographyGrid\n&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = grid.create_export(\"zarr\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.get_export","title":"get_export","text":"<pre><code>get_export(export_format: str) -&gt; Export\n</code></pre> <p>Get the status of an existing export.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>Format of the export to check. Must be one of: - \"zarr\": Compressed array format - \"geotiff\": GeoTIFF format</p> required <p>Returns:</p> Type Description <code>Export</code> <p>An Export object containing current status</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TopographyGrid\n&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; export = grid.create_export(\"zarr\")\n&gt;&gt;&gt; export.wait_until_completed()\n&gt;&gt;&gt; export.to_file(\"grid_data.zarr\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGrid.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this topography grid.</p> <p>Permanently removes topography grid data from the domain. This also cancels any ongoing processing jobs.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastfuels_sdk import TopographyGrid\n&gt;&gt;&gt; grid = TopographyGrid.from_domain_id(\"abc123\")\n&gt;&gt;&gt; # Remove grid when no longer needed\n&gt;&gt;&gt; grid.delete()\n&gt;&gt;&gt; # Subsequent operations will raise NotFoundException\n&gt;&gt;&gt; grid.get()  # raises NotFoundException\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder","title":"TreeGridBuilder","text":"<p>Builder for creating tree grids with complex attribute configurations.</p>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.with_bulk_density_from_tree_inventory","title":"with_bulk_density_from_tree_inventory","text":"<pre><code>with_bulk_density_from_tree_inventory() -&gt; 'TreeGridBuilder'\n</code></pre> <p>Add bulk density attribute from tree inventory data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = TreeGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_bulk_density_from_tree_inventory()\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.with_uniform_bulk_density","title":"with_uniform_bulk_density","text":"<pre><code>with_uniform_bulk_density(value: float) -&gt; 'TreeGridBuilder'\n</code></pre> <p>Set uniform bulk density value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Bulk density value in kg/m\u00b3</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = TreeGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_bulk_density(0.5)\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.with_savr_from_tree_inventory","title":"with_savr_from_tree_inventory","text":"<pre><code>with_savr_from_tree_inventory() -&gt; 'TreeGridBuilder'\n</code></pre> <p>Add surface area to volume ratio (SAVR) attribute from tree inventory data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = TreeGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_savr_from_tree_inventory()\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.with_spcd_from_tree_inventory","title":"with_spcd_from_tree_inventory","text":"<pre><code>with_spcd_from_tree_inventory() -&gt; 'TreeGridBuilder'\n</code></pre> <p>Add species code (SPCD) attribute from tree inventory data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = TreeGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_spcd_from_tree_inventory()\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.with_uniform_fuel_moisture","title":"with_uniform_fuel_moisture","text":"<pre><code>with_uniform_fuel_moisture(value: float) -&gt; 'TreeGridBuilder'\n</code></pre> <p>Set uniform fuel moisture value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Fuel moisture value (%)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = TreeGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fuel_moisture(15.0)  # 15%\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.build","title":"build","text":"<pre><code>build() -&gt; 'TreeGrid'\n</code></pre> <p>Create the tree grid with configured attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tree_grid = (TreeGridBuilder(\"abc123\")\n...     .with_bulk_density_from_tree_inventory()\n...     .with_spcd_from_tree_inventory()\n...     .with_uniform_fuel_moisture(15.0)\n...     .build())\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.clear","title":"clear","text":"<pre><code>clear() -&gt; 'TreeGridBuilder'\n</code></pre> <p>Clear all configured attributes.</p>"},{"location":"reference/#fastfuels_sdk.grids.TreeGridBuilder.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Return the dictionary representation of the builder configuration.</p>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder","title":"SurfaceGridBuilder","text":"<p>Builder for creating surface grids with complex attribute configurations.</p>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_fuel_load","title":"with_uniform_fuel_load","text":"<pre><code>with_uniform_fuel_load(value: float, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform fuel load value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Fuel load value in kg/m\u00b2</p> required <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fuel_load(value=0.5, feature_masks=[\"road\", \"water\"])\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_fuel_load_by_size_class","title":"with_uniform_fuel_load_by_size_class","text":"<pre><code>with_uniform_fuel_load_by_size_class(one_hour: float = None, ten_hour: float = None, hundred_hour: float = None, live_herbaceous: float = None, live_woody: float = None, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform fuel load values by size class.</p> <p>Parameters:</p> Name Type Description Default <code>one_hour</code> <code>float</code> <p>1-hour fuel load value in kg/m\u00b2.</p> <code>None</code> <code>ten_hour</code> <code>float</code> <p>10-hour fuel load value in kg/m\u00b2.</p> <code>None</code> <code>hundred_hour</code> <code>float</code> <p>100-hour fuel load value in kg/m\u00b2.</p> <code>None</code> <code>live_herbaceous</code> <code>float</code> <p>Live herbaceous fuel load value in kg/m\u00b2.</p> <code>None</code> <code>live_woody</code> <code>float</code> <p>Live woody fuel load value in kg/m\u00b2.</p> <code>None</code> <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fuel_load_by_size_class(\n...     one_hour=0.5,\n...     ten_hour=1.0,\n...     hundred_hour=2.0,\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre> Notes <p>Only size classes with provided values will be included in the configuration.</p>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_fuel_load_from_landfire","title":"with_fuel_load_from_landfire","text":"<pre><code>with_fuel_load_from_landfire(product: str, version: str = '2022', interpolation_method: str = 'nearest', curing_live_herbaceous: float = 0.0, curing_live_woody: float = 0.0, groups: List[str] = None, feature_masks: list[str] = None, remove_non_burnable: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Configure fuel load from LANDFIRE source.</p> <p>Parameters:</p> Name Type Description Default <code>product</code> <code>str</code> <p>LANDFIRE product name (\"FBFM40\", \"FBFM13\", or \"FCCS\")</p> required <code>version</code> <code>str</code> <p>LANDFIRE version, default \"2022\"</p> <code>'2022'</code> <code>interpolation_method</code> <code>str</code> <p>Method for interpolation, default \"nearest\"</p> <code>'nearest'</code> <code>curing_live_herbaceous</code> <code>float</code> <p>Proportion of live herbaceous fuel that is cured, defaults to 0.</p> <code>0.0</code> <code>curing_live_woody</code> <code>float</code> <p>Proportion of live woody fuel that is cured, defaults to 0.</p> <code>0.0</code> <code>groups</code> <code>list[str]</code> <p>List of fuel load groups to include. Can be: \"oneHour\", \"tenHour\", \"hundredHour\", \"liveHerbaceous\", \"liveWoody\"</p> <code>None</code> <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <code>remove_non_burnable</code> <code>list[str]</code> <p>List of non-burnable fuel models to remove. This option is often used in conjunction with feature_masks to improve the resolution of landscape features. Can be: \"NB1\", \"NB2\", \"NB3\", \"NB8\", \"NB9\"</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_fuel_load_from_landfire(\n...     product=\"FBFM40\",\n...     version=\"2022\",\n...     interpolation_method=\"nearest\",\n...     curing_live_herbaceous=0.25,\n...     curing_live_woody=0.1,\n...     groups=[\"oneHour\", \"tenHour\", \"hundredHour\"],\n...     feature_masks=[\"road\", \"water\"],\n...     remove_non_burnable=[\"NB1\", \"NB2\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_fuel_depth","title":"with_uniform_fuel_depth","text":"<pre><code>with_uniform_fuel_depth(value: float, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform fuel depth value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Fuel depth in meters</p> required <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fuel_depth(value=0.3, feature_masks=[\"road\", \"water\"])\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_fuel_depth_from_landfire","title":"with_fuel_depth_from_landfire","text":"<pre><code>with_fuel_depth_from_landfire(product: str, version: str = '2022', interpolation_method: str = 'nearest', feature_masks: list[str] = None, remove_non_burnable: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Configure fuel depth from LANDFIRE source.</p> <p>Parameters:</p> Name Type Description Default <code>product</code> <code>str</code> <p>LANDFIRE product name (\"FBFM40\", \"FBFM13\", or \"FCCS)</p> required <code>version</code> <code>str</code> <p>LANDFIRE version, default \"2022\"</p> <code>'2022'</code> <code>interpolation_method</code> <code>str</code> <p>Method for interpolation, default \"nearest\"</p> <code>'nearest'</code> <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <code>remove_non_burnable</code> <code>list[str]</code> <p>List of non-burnable fuel models to remove. This option is often used in conjunction with feature_masks to improve the resolution of landscape features. Can be: \"NB1\", \"NB2\", \"NB3\", \"NB8\", \"NB9\"</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_fuel_depth_from_landfire(\n...     product=\"FBFM40\",\n...     version=\"2022\",\n...     interpolation_method=\"nearest\",\n...     feature_masks=[\"road\", \"water\"],\n...     remove_non_burnable=[\"NB1\", \"NB2\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_fuel_moisture","title":"with_uniform_fuel_moisture","text":"<pre><code>with_uniform_fuel_moisture(value: float, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform fuel moisture value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Fuel moisture value (%).</p> required <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fuel_moisture(\n...     value=15.0,  # 15%\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_fuel_moisture_by_size_class","title":"with_uniform_fuel_moisture_by_size_class","text":"<pre><code>with_uniform_fuel_moisture_by_size_class(one_hour: float = None, ten_hour: float = None, hundred_hour: float = None, live_herbaceous: float = None, live_woody: float = None, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform fuel moisture values by size class.</p> <p>Parameters:</p> Name Type Description Default <code>one_hour</code> <code>float</code> <p>1-hour fuel moisture content (%).</p> <code>None</code> <code>ten_hour</code> <code>float</code> <p>10-hour fuel moisture content (%).</p> <code>None</code> <code>hundred_hour</code> <code>float</code> <p>100-hour fuel moisture content (%).</p> <code>None</code> <code>live_herbaceous</code> <code>float</code> <p>Live herbaceous fuel moisture content (%).</p> <code>None</code> <code>live_woody</code> <code>float</code> <p>Live woody fuel moisture content (%).</p> <code>None</code> <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fuel_moisture_by_size_class(\n...     one_hour=10.0,\n...     ten_hour=15.0,\n...     hundred_hour=20.0,\n...     live_herbaceous=75.0,\n...     live_woody=90.0,\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_fbfm","title":"with_uniform_fbfm","text":"<pre><code>with_uniform_fbfm(value: str, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform Fire Behavior Fuel Model.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>FBFM value (e.g. \"9\", \"GR2\")</p> required <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_fbfm(\"GR2\")\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_fbfm_from_landfire","title":"with_fbfm_from_landfire","text":"<pre><code>with_fbfm_from_landfire(product: str, version: str = '2022', interpolation_method: str = 'nearest', feature_masks: list[str] = None, remove_non_burnable: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Configure FBFM from LANDFIRE source.</p> <p>Parameters:</p> Name Type Description Default <code>product</code> <code>str</code> <p>LANDFIRE product to use (\"FBFM40\" or \"FBFM13\")</p> required <code>version</code> <code>str</code> <p>LANDFIRE version, default \"2022\"</p> <code>'2022'</code> <code>interpolation_method</code> <code>str</code> <p>Method for interpolation, default \"nearest\"</p> <code>'nearest'</code> <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <code>remove_non_burnable</code> <code>list[str]</code> <p>List of non-burnable fuel models to remove. This option is often used in conjunction with feature_masks to improve the resolution of landscape features. Can be: \"NB1\", \"NB2\", \"NB3\", \"NB8\", \"NB9\"</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_fbfm_from_landfire(\n...     product=\"FBFM40\",\n...     version=\"2022\",\n...     interpolation_method=\"nearest\",\n...     feature_masks=[\"road\", \"water\"],\n...     remove_non_burnable=[\"NB1\", \"NB2\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_uniform_savr","title":"with_uniform_savr","text":"<pre><code>with_uniform_savr(value: float, feature_masks: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Set uniform Surface Area to Volume Ratio (SAVR).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>SAVR value in m\u00b2/m\u00b3</p> required <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_uniform_savr(\n...     value=9000, # m\u00b2/m\u00b3\n...     feature_masks=[\"road\", \"water\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_savr_from_landfire","title":"with_savr_from_landfire","text":"<pre><code>with_savr_from_landfire(product: str, version: str = '2022', interpolation_method: str = 'nearest', groups: List[str] = None, feature_masks: list[str] = None, remove_non_burnable: list[str] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Configure SAVR from LANDFIRE source.</p> <p>Parameters:</p> Name Type Description Default <code>product</code> <code>str</code> <p>LANDFIRE product to use (\"FBFM40\" or \"FBFM13\")</p> required <code>version</code> <code>str</code> <p>LANDFIRE version, default \"2022\"</p> <code>'2022'</code> <code>interpolation_method</code> <code>str</code> <p>Method for interpolation, default \"nearest\"</p> <code>'nearest'</code> <code>groups</code> <code>list[str]</code> <p>List of SAVR groups to include. Can be: \"oneHour\", \"tenHour\", \"hundredHour\", \"liveHerbaceous\", \"liveWoody\"</p> <code>None</code> <code>feature_masks</code> <code>list[str]</code> <p>List of feature masks to apply to the surface grid attribute. Can be \"road\" or \"water\". Note that including these masks requires a feature grid with the appropriate attributes to have a \"completed\" status.</p> <code>None</code> <code>remove_non_burnable</code> <code>list[str]</code> <p>List of non-burnable fuel models to remove. This option is often used in conjunction with feature_masks to improve the resolution of landscape features. Can be: \"NB1\", \"NB2\", \"NB3\", \"NB8\", \"NB9\"</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_savr_from_landfire(\n...     product=\"FBFM40\",\n...     version=\"2022\",\n...     interpolation_method=\"nearest\",\n...     groups=[\"oneHour\", \"tenHour\", \"hundredHour\"],\n...     feature_masks=[\"road\", \"water\"],\n...     remove_non_burnable=[\"NB1\", \"NB2\"]\n... )\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.with_modification","title":"with_modification","text":"<pre><code>with_modification(actions: dict | list[dict] | SurfaceGridModificationAction | list[SurfaceGridModificationAction], conditions: dict | list[dict] | SurfaceGridModificationCondition | list[SurfaceGridModificationCondition] = None) -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Add a modification to the surface grid.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>dict or list[dict] or SurfaceGridModificationAction or list[SurfaceGridModificationAction]</code> <p>Action to apply to the surface grid. Can be a single action or a list of actions.</p> required <code>conditions</code> <code>dict or list[dict] or SurfaceGridModificationCondition or list[SurfaceGridModificationCondition]</code> <p>Condition(s) to apply the action. Can be a single condition or a list of conditions.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; builder = SurfaceGridBuilder(\"abc123\")\n&gt;&gt;&gt; builder.with_modification(\n...     actions={\"attribute\": \"FBFM\", \"modifier\": \"replace\", \"value\": \"GR2\"},\n...     conditions={\"attribute\": \"FBFM\", \"operator\": \"eq\", \"value\": \"GR1\"}\n... )  # Replace all FBFM values that are GR1 with GR2\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.build","title":"build","text":"<pre><code>build() -&gt; 'SurfaceGrid'\n</code></pre> <p>Create the surface grid with configured attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; surface_grid = (SurfaceGridBuilder(\"abc123\")\n...     .with_uniform_fuel_load(0.5)\n...     .with_uniform_fuel_moisture(15.0)\n...     .with_fbfm_from_landfire(\"FBFM40\")\n...     .build())\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.SurfaceGridBuilder.clear","title":"clear","text":"<pre><code>clear() -&gt; 'SurfaceGridBuilder'\n</code></pre> <p>Clear all configured attributes.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder","title":"TopographyGridBuilder","text":"<p>Builder for creating topography grids with complex attribute configurations.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_elevation_from_3dep","title":"with_elevation_from_3dep","text":"<pre><code>with_elevation_from_3dep(interpolation_method: str = 'cubic') -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add elevation attribute from 3DEP data.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_elevation_from_landfire","title":"with_elevation_from_landfire","text":"<pre><code>with_elevation_from_landfire(interpolation_method: str = 'cubic') -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add elevation attribute from LANDFIRE data.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_elevation_from_uniform_value","title":"with_elevation_from_uniform_value","text":"<pre><code>with_elevation_from_uniform_value(value: float) -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add elevation attribute with uniform value.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_aspect_from_3dep","title":"with_aspect_from_3dep","text":"<pre><code>with_aspect_from_3dep() -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add aspect attribute from 3DEP data.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_aspect_from_landfire","title":"with_aspect_from_landfire","text":"<pre><code>with_aspect_from_landfire() -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add aspect attribute from LANDFIRE data.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_slope_from_3dep","title":"with_slope_from_3dep","text":"<pre><code>with_slope_from_3dep(interpolation_method: str = 'cubic') -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add slope attribute from 3DEP data.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.with_slope_from_landfire","title":"with_slope_from_landfire","text":"<pre><code>with_slope_from_landfire(interpolation_method: str = 'cubic') -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Add slope attribute from LANDFIRE data.</p>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.build","title":"build","text":"<pre><code>build() -&gt; 'TopographyGrid'\n</code></pre> <p>Create the surface grid with configured attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; topography_grid = (TopographyGridBuilder(domain_id=\"abc123\")\n...     .with_elevation_from_3dep()\n...     .with_slope_from_3dep()\n...     .with_aspect_from_landfire()\n...     .build())\n</code></pre>"},{"location":"reference/#fastfuels_sdk.grids.TopographyGridBuilder.clear","title":"clear","text":"<pre><code>clear() -&gt; 'TopographyGridBuilder'\n</code></pre> <p>Clear all configured attributes.</p>"},{"location":"reference/#fastfuels_sdk.exports","title":"fastfuels_sdk.exports","text":"<p>exports.py</p>"},{"location":"reference/#fastfuels_sdk.exports.Export","title":"Export","text":"<p>               Bases: <code>Export</code></p> <p>Class for handling exports of various resources from the FastFuels API. Inherits from the base ExportModel and adds functionality for fetching, waiting for completion, and downloading exports.</p> <p>Attributes:</p> Name Type Description <code>domain_id</code> <code>str</code> <p>The ID of the domain associated with the export</p> <code>resource</code> <code>str</code> <p>The type of resource being exported (e.g. \"inventories\")</p> <code>sub_resource</code> <code>str</code> <p>The specific sub-resource being exported (e.g. \"tree\")</p> <code>format</code> <code>str</code> <p>The format of the export (e.g. \"csv\", \"parquet\", \"geojson\")</p> <code>status</code> <code>str</code> <p>Current status of the export (\"pending\", \"running\", \"completed\")</p> <code>signed_url</code> <code>(str, optional)</code> <p>URL for downloading the completed export</p> <code>_api_get_method</code> <code>Callable</code> <p>The API method to use for getting the export status</p>"},{"location":"reference/#fastfuels_sdk.exports.Export.__init__","title":"__init__","text":"<pre><code>__init__(**data: Any)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>Keyword arguments that match the ExportModel fields</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the resource and sub_resource combination is not supported</p>"},{"location":"reference/#fastfuels_sdk.exports.Export.get","title":"get","text":"<pre><code>get(in_place: bool = False) -&gt; Export\n</code></pre> <p>Fetches the current state of the export from the API.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, updates the current object with fetched data. If False, returns a new Export object. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Export</code> <p>Either the current object updated with fresh data (in_place=True) or a new Export object with the fetched data (in_place=False)</p>"},{"location":"reference/#fastfuels_sdk.exports.Export.wait_until_completed","title":"wait_until_completed","text":"<pre><code>wait_until_completed(step: float = 5, timeout: float = 600, in_place: bool = True, verbose: bool = False) -&gt; Export\n</code></pre> <p>Waits for the export to complete, polling at regular intervals.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Time in seconds between status checks. Default is 5.</p> <code>5</code> <code>timeout</code> <code>float</code> <p>Maximum time in seconds to wait for completion. Default is 600.</p> <code>600</code> <code>in_place</code> <code>bool</code> <p>If True, updates the current object with the completed export data. If False, returns a new Export object. Default is True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, prints status updates during the wait. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Export</code> <p>The completed export object</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the export does not complete within the specified timeout period.</p>"},{"location":"reference/#fastfuels_sdk.exports.Export.to_file","title":"to_file","text":"<pre><code>to_file(path: Path | str) -&gt; None\n</code></pre> <p>Downloads the export to a local file once it's completed.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path or str</code> <p>The path where the export should be saved. If a directory is provided, the file will be saved as \"{resource}_{sub_resource}.{format}\" in that directory.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the export is not yet completed or if the signed URL is missing</p>"},{"location":"reference/#fastfuels_sdk.convenience","title":"fastfuels_sdk.convenience","text":"<p>fastfuels_sdk/convenience.py</p>"},{"location":"reference/#fastfuels_sdk.convenience.export_roi","title":"export_roi","text":"<pre><code>export_roi(roi: GeoDataFrame, export_path: Path | str, export_format: str = 'QUIC-Fire', verbose: bool = False, topography_config: Optional[Dict[str, Any]] = None, surface_config: Optional[Dict[str, Any]] = None, tree_config: Optional[Dict[str, Any]] = None, features_config: Optional[Dict[str, Any]] = None, tree_inventory_config: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Export\n</code></pre> <p>Convenience function to export a region of interest (ROI) to various formats.</p> <p>This function creates all necessary grids and resources to export spatial data in formats compatible with fire modeling software. It handles the complete workflow from domain creation through final export file generation.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the region of interest geometry. Should contain polygon geometries defining the spatial extent for the export.</p> required <code>export_path</code> <code>Path or str</code> <p>File path where the export will be saved. The export is typically saved as a ZIP file containing all required data files.</p> required <code>export_format</code> <code>str</code> <p>Format for the export. Supported formats: - \"QUIC-Fire\" (default): Multi-grid bundle for QUIC-Fire fire modeling - \"zarr\": Multi-grid export in zarr array format</p> <code>'QUIC-Fire'</code> <code>verbose</code> <code>bool</code> <p>If True, prints progress messages during the export process. Default is False.</p> <code>False</code> <code>topography_config</code> <code>dict</code> <p>Configuration for topography grid creation. If None, uses default 3DEP elevation data with linear interpolation.</p> <p>Structure::</p> <pre><code>{\n    \"attributes\": [\"elevation\"],\n    \"elevation\": {\n        \"source\": \"3DEP\" | \"LANDFIRE\" | \"uniform\",\n        \"interpolationMethod\": \"linear\" | \"cubic\" | \"nearest\",\n        \"value\": float  # Required only for uniform source\n    }\n}\n</code></pre> <code>None</code> <code>surface_config</code> <code>dict</code> <p>Configuration for surface fuel grid creation. If None, uses default LANDFIRE FBFM40 (2022) data with standard curing rates and 15% fuel moisture.</p> <p>Structure::</p> <pre><code>{\n    \"attributes\": [\"fuelLoad\", \"fuelDepth\", \"fuelMoisture\"],\n    \"fuelLoad\": {\n        \"source\": \"LANDFIRE\" | \"uniform\",\n        \"product\": \"FBFM40\",  # LANDFIRE product\n        \"version\": \"2022\",    # LANDFIRE version\n        \"interpolationMethod\": \"cubic\" | \"linear\" | \"nearest\",\n        \"curingLiveHerbaceous\": 0.25,  # 0.0-1.0\n        \"curingLiveWoody\": 0.1,        # 0.0-1.0\n        \"groups\": [\"oneHour\", \"tenHour\", ...],\n        \"featureMasks\": [\"road\", \"water\"],\n        \"removeNonBurnable\": [\"NB1\", \"NB2\", ...],\n        \"value\": float  # Required for uniform source\n    },\n    \"fuelDepth\": {\n        \"source\": \"LANDFIRE\" | \"uniform\",\n        # Similar structure to fuelLoad\n    },\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",\n        \"value\": 0.15,  # Fuel moisture content (0.0-1.0)\n        \"featureMasks\": [\"road\", \"water\"]\n    }\n}\n</code></pre> <code>None</code> <code>tree_config</code> <code>dict</code> <p>Configuration for tree canopy grid creation. If None, uses tree inventory data for bulk density and 100% fuel moisture.</p> <p>Structure::</p> <pre><code>{\n    \"attributes\": [\"bulkDensity\", \"fuelMoisture\"],\n    \"bulkDensity\": {\n        \"source\": \"inventory\" | \"uniform\",\n        \"value\": float  # Required for uniform source\n    },\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",\n        \"value\": 100  # Fuel moisture content\n    }\n}\n</code></pre> <code>None</code> <code>features_config</code> <code>dict</code> <p>Configuration for geographic features creation. If None, creates both road and water features from OpenStreetMap data.</p> <p>Structure::</p> <pre><code>{\n    \"createRoadFeatures\": True,    # Create road features\n    \"createWaterFeatures\": True,   # Create water features\n    \"featureGridAttributes\": [\"road\", \"water\"]  # Grid attributes\n}\n</code></pre> <code>None</code> <code>tree_inventory_config</code> <code>dict</code> <p>Configuration for tree inventory creation. If None, uses TreeMap data with road and water feature masks.</p> <p>Structure::</p> <pre><code>{\n    \"featureMasks\": [\"road\", \"water\"],  # Features to mask out\n    \"canopyHeightMapSource\": \"Meta2024\",  # High-resolution canopy height map\n    \"version\": \"2022\",  # TreeMap version\n    \"seed\": 42,  # Random seed for reproducibility\n    \"modifications\": [  # Tree attribute modifications\n        {\n            \"conditions\": [{\"attribute\": \"CR\", \"operator\": \"gt\", \"value\": 0.1}],\n            \"actions\": [{\"attribute\": \"CR\", \"modifier\": \"multiply\", \"value\": 0.9}]\n        }\n    ],\n    \"treatments\": [  # Silvicultural treatments\n        {\n            \"method\": \"proportionalThinning\",\n            \"targetMetric\": \"basalArea\",\n            \"targetValue\": 25.0\n        }\n    ]\n}\n</code></pre> <code>None</code> <p>Returns:</p> Type Description <code>Export</code> <p>The completed export object. The export will have \"completed\" status, and the data will be saved to the specified export_path.</p> <p>Examples:</p> <p>Basic usage with default settings (QUIC-Fire format):</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from fastfuels_sdk import export_roi\n&gt;&gt;&gt; roi = gpd.read_file(\"my_area.geojson\")\n&gt;&gt;&gt; export = export_roi(roi, \"quicfire_export.zip\")\n</code></pre> <p>Export in zarr format:</p> <pre><code>&gt;&gt;&gt; export = export_roi(roi, \"data_export.zip\", export_format=\"zarr\")\n</code></pre> <p>Customize surface fuel moisture to 5% (dry conditions):</p> <pre><code>&gt;&gt;&gt; surface_config = {\n...     \"fuelMoisture\": {\n...         \"source\": \"uniform\",\n...         \"value\": 0.05,\n...         \"featureMasks\": [\"road\", \"water\"]\n...     }\n... }\n&gt;&gt;&gt; export = export_roi(\n...     roi, \"dry_export.zip\",\n...     surface_config=surface_config\n... )\n</code></pre> <p>Use LANDFIRE 2023 data and disable water features:</p> <pre><code>&gt;&gt;&gt; surface_config = {\n...     \"fuelLoad\": {\"version\": \"2023\"},\n...     \"fuelDepth\": {\"version\": \"2023\"}\n... }\n&gt;&gt;&gt; features_config = {\"createWaterFeatures\": False}\n&gt;&gt;&gt; export = export_roi(\n...     roi, \"landfire_2023.zip\",\n...     surface_config=surface_config,\n...     features_config=features_config\n... )\n</code></pre> <p>Apply tree inventory modifications to reduce crown ratio:</p> <pre><code>&gt;&gt;&gt; tree_inventory_config = {\n...     \"modifications\": [\n...         {\n...             \"conditions\": [{\"attribute\": \"CR\", \"operator\": \"gt\", \"value\": 0.1}],\n...             \"actions\": [{\"attribute\": \"CR\", \"modifier\": \"multiply\", \"value\": 0.9}]\n...         }\n...     ]\n... }\n&gt;&gt;&gt; export = export_roi(\n...     roi, \"modified_trees.zip\",\n...     tree_inventory_config=tree_inventory_config\n... )\n</code></pre> <p>Apply silvicultural treatments and remove small trees:</p> <pre><code>&gt;&gt;&gt; tree_inventory_config = {\n...     \"modifications\": [\n...         {\n...             \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n...             \"actions\": [{\"attribute\": \"all\", \"modifier\": \"remove\"}]\n...         }\n...     ],\n...     \"treatments\": [\n...         {\n...             \"method\": \"proportionalThinning\",\n...             \"targetMetric\": \"basalArea\",\n...             \"targetValue\": 25.0\n...         }\n...     ]\n... }\n&gt;&gt;&gt; export = export_roi(\n...     roi, \"thinned_forest.zip\",\n...     tree_inventory_config=tree_inventory_config\n... )\n</code></pre> Notes <p>This function performs the complete export workflow:</p> <ol> <li>Creates a domain from the input ROI geometry</li> <li>Creates road and water features from OpenStreetMap (if enabled)</li> <li>Generates topography grid from elevation data</li> <li>Creates feature grid from road/water features</li> <li>Builds tree inventory from TreeMap data</li> <li>Generates surface fuel grid from LANDFIRE data</li> <li>Creates tree canopy grid from inventory data</li> <li>Exports all grids in the specified format</li> </ol> <p>All configuration parameters support partial overrides - only specify the values you want to change from the defaults. The function will merge your configuration with sensible defaults for all other parameters.</p> <p>Tree Inventory Modifications and Treatments:</p> <p>When both modifications and treatments are specified in tree_inventory_config, they are applied in the following order:</p> <ol> <li>Modifications are applied first to adjust or remove individual trees    based on their attributes (height, diameter, crown ratio, species)</li> <li>Treatments are then applied to the modified inventory to achieve    target stand-level metrics (basal area, density)</li> </ol> <p>Use modifications when you want to: - Adjust specific tree attributes (e.g., multiply heights by 0.9) - Remove trees matching certain criteria (e.g., diameter &lt; 10 cm) - Apply expression-based conditions (e.g., crown length &lt; 1 m)</p> <p>Use treatments when you want to: - Apply silvicultural operations (proportional or directional thinning) - Achieve target stand metrics (e.g., basal area of 25 m\u00b2/ha) - Simulate forest management scenarios</p>"},{"location":"reference/#fastfuels_sdk.convenience.export_roi_to_quicfire","title":"export_roi_to_quicfire","text":"<pre><code>export_roi_to_quicfire(roi: GeoDataFrame, export_path: Path | str, verbose: bool = False, topography_config: Optional[Dict[str, Any]] = None, surface_config: Optional[Dict[str, Any]] = None, tree_config: Optional[Dict[str, Any]] = None, features_config: Optional[Dict[str, Any]] = None, tree_inventory_config: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Export\n</code></pre> <p>Convenience function to export a region of interest (ROI) to QUIC-Fire.</p> <p>This is a convenience wrapper around export_roi() that sets export_format to \"QUIC-Fire\". For more flexible export options including zarr format, use export_roi() directly.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the region of interest geometry.</p> required <code>export_path</code> <code>Path or str</code> <p>File path where the QUIC-Fire export will be saved.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints progress messages during the export process.</p> <code>False</code> <code>topography_config</code> <code>dict</code> <p>Configuration for topography grid creation. See export_roi() for details.</p> <code>None</code> <code>surface_config</code> <code>dict</code> <p>Configuration for surface fuel grid creation. See export_roi() for details.</p> <code>None</code> <code>tree_config</code> <code>dict</code> <p>Configuration for tree canopy grid creation. See export_roi() for details.</p> <code>None</code> <code>features_config</code> <code>dict</code> <p>Configuration for geographic features creation. See export_roi() for details.</p> <code>None</code> <code>tree_inventory_config</code> <code>dict</code> <p>Configuration for tree inventory creation. See export_roi() for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>Export</code> <p>The completed QUIC-Fire export object.</p> See Also <p>export_roi : More flexible export function supporting multiple formats.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from fastfuels_sdk import export_roi_to_quicfire\n&gt;&gt;&gt; roi = gpd.read_file(\"my_area.geojson\")\n&gt;&gt;&gt; export = export_roi_to_quicfire(roi, \"quicfire_export.zip\")\n</code></pre>"},{"location":"guides/authentication/","title":"How to Set Up Authentication for FastFuels SDK","text":"<p>This guide shows you how to configure API authentication for the FastFuels SDK in different environments.</p>"},{"location":"guides/authentication/#how-to-configure-authentication-using-environment-variables","title":"How to Configure Authentication Using Environment Variables","text":"<p>For production environments, set your API key as an environment variable:</p> <pre><code># Linux/MacOS\nexport FASTFUELS_API_KEY=\"your-api-key-here\"\n\n# Windows (Command Prompt)\nset FASTFUELS_API_KEY=your-api-key-here\n\n# Windows (PowerShell)\n$env:FASTFUELS_API_KEY=\"your-api-key-here\"\n</code></pre> <p>Then import and use the SDK - it will automatically use the environment variable:</p> <pre><code>from fastfuels_sdk import api\nfrom fastfuels_sdk.domains import Domain\n\n# SDK automatically uses FASTFUELS_API_KEY environment variable\ndomain = Domain.from_id(\"your-domain-id\")\n</code></pre>"},{"location":"guides/authentication/#how-to-configure-authentication-programmatically","title":"How to Configure Authentication Programmatically","text":"<p>For development or testing environments, set the API key in your code:</p> <pre><code>from fastfuels_sdk import api\n\n# Configure the API key\napi.set_api_key(\"your-api-key-here\")\n\n# SDK will now use this key for all operations\n</code></pre>"},{"location":"guides/authentication/#how-to-handle-missing-authentication","title":"How to Handle Missing Authentication","text":"<p>Add error handling for cases where authentication isn't properly configured:</p> <pre><code>from fastfuels_sdk import api\nfrom fastfuels_sdk.client_library.exceptions import UnauthorizedException\n\ntry:\n    # Will raise UnauthorizedException if no API key is configured\n    from fastfuels_sdk.domains import Domain\n    domain = Domain.from_id(\"your-domain-id\")\nexcept UnauthorizedException as e:\n    print(f\"Authentication error: {e}\")\n    # Add your error handling logic here\n</code></pre>"},{"location":"guides/authentication/#how-to-update-authentication-at-runtime","title":"How to Update Authentication at Runtime","text":"<p>If you need to switch API keys during execution:</p> <pre><code>from fastfuels_sdk import api\n\ndef switch_auth_key(new_key: str) -&gt; None:\n    \"\"\"Update authentication to use a new API key.\"\"\"\n    api.set_api_key(new_key)\n\n# Usage\nswitch_auth_key(\"new-api-key\")\n</code></pre> <p>Remember: The API client is maintained as a singleton, so setting a new API key affects all subsequent operations in your application.</p>"},{"location":"guides/domains/","title":"How to Work with Domains in FastFuels SDK","text":""},{"location":"guides/domains/#create-a-domain-from-geojson","title":"Create a Domain from GeoJSON","text":"<p>To create a domain from a GeoJSON file:</p> <pre><code>import json\nfrom fastfuels_sdk.domains import Domain\n\nwith open(\"area.geojson\") as f:\n    geojson = json.load(f)\n\ndomain = Domain.from_geojson(\n    geojson=geojson,\n    name=\"My Domain\",\n    description=\"Forest area for analysis\",\n    horizontal_resolution=2.0,\n    vertical_resolution=1.0\n)\n</code></pre>"},{"location":"guides/domains/#create-a-domain-from-a-geodataframe","title":"Create a Domain from a GeoDataFrame","text":"<p>If your spatial data is in a format supported by GeoPandas (Shapefile, KML etc.):</p> <pre><code>import geopandas as gpd\nfrom fastfuels_sdk.domains import Domain\n\ngdf = gpd.read_file(\"forest_area.shp\")\n\ndomain = Domain.from_geodataframe(\n    geodataframe=gdf,\n    name=\"Forest Domain\",\n    description=\"Imported from shapefile\",\n    horizontal_resolution=2.0\n)\n</code></pre>"},{"location":"guides/domains/#retrieve-an-existing-domain","title":"Retrieve an Existing Domain","text":"<p>To fetch a domain using its ID:</p> <pre><code>domain = Domain.from_id(\"abc123\")\n</code></pre>"},{"location":"guides/domains/#update-domain-properties","title":"Update Domain Properties","text":"<p>To modify a domain's name, description or tags:</p> <pre><code># Create new instance with updates\nupdated_domain = domain.update(\n    name=\"New Name\",\n    description=\"Updated description\",\n    tags=[\"forest\", \"analysis\"]\n)\n\n# Or update in-place\ndomain.update(\n    name=\"New Name\",\n    in_place=True\n)\n</code></pre>"},{"location":"guides/domains/#get-fresh-domain-data","title":"Get Fresh Domain Data","text":"<p>To fetch the latest data for a domain:</p> <pre><code># Get new instance with fresh data\nfresh_domain = domain.get()\n\n# Or refresh existing instance\ndomain.get(in_place=True)\n</code></pre>"},{"location":"guides/domains/#list-available-domains","title":"List Available Domains","text":"<p>To list domains with pagination:</p> <pre><code>from fastfuels_sdk.domains import list_domains\n\n# Get first page with default size (100)\nresponse = list_domains()\n\n# Custom page and size\nresponse = list_domains(\n    page=2,\n    size=50,\n    sort_by=\"name\",\n    sort_order=\"ascending\"\n)\n\nfor domain in response.domains:\n    print(f\"{domain.id}: {domain.name}\")\n</code></pre>"},{"location":"guides/domains/#delete-a-domain","title":"Delete a Domain","text":"<p>To permanently delete a domain:</p> <pre><code>domain.delete()\n</code></pre>"},{"location":"guides/features/","title":"How to Work with Features in FastFuels SDK","text":"<p>This guide shows you how to work with geographic features (roads and water bodies) in your domains using the FastFuels SDK.</p>"},{"location":"guides/features/#get-features-for-a-domain","title":"Get Features for a Domain","text":"<p>Features are always associated with a domain. To access features:</p> <pre><code>from fastfuels_sdk import Features\n\n# Get Feature data from an existing domain ID.\nfeatures = Features.from_domain_id(\"your_domain_id\")\n</code></pre>"},{"location":"guides/features/#check-what-features-exist","title":"Check what features exist","text":"<p>if features.road:     print(\"Domain has road features\") if features.water:     print(\"Domain has water features\") <pre><code>## Create Road Features\n\n### Basic Road Feature Creation\n\nThe simplest way to create road features is using OpenStreetMap (OSM) data:\n\n```python\n# Using the convenience method\nroad = features.create_road_feature_from_osm()\n\n# Or the general method\nroad = features.create_road_feature(sources=\"OSM\")\n</code></pre></p>"},{"location":"guides/features/#update-features-instance","title":"Update Features Instance","text":"<p>To automatically update the Features object when creating road features:</p> <pre><code># Create features and update the Features instance\nroad = features.create_road_feature_from_osm(in_place=True)\n\n# Now features.road points to the new road features\nassert features.road is road\n</code></pre>"},{"location":"guides/features/#create-road-features-from-geojsongeodataframe","title":"Create Road Features from GeoJSON/GeoDataFrame","text":"<p>You can also create road features from your own GeoJSON data or GeoPandas GeoDataFrame. This is particularly useful for: - Custom road data not available in OSM - Local coordinate system domains (OSM is not supported for local CRS) - Integration with existing geospatial workflows</p>"},{"location":"guides/features/#using-geojson","title":"Using GeoJSON","text":"<pre><code># Define your road areas as GeoJSON\ngeojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [{\n        \"type\": \"Feature\",\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [[\n                [-120.5, 39.5],\n                [-120.5, 39.6],\n                [-120.4, 39.6],\n                [-120.4, 39.5],\n                [-120.5, 39.5]\n            ]]\n        },\n        \"properties\": {}\n    }]\n}\n\n# Create road features from GeoJSON\nroad = features.create_road_feature(sources=\"geojson\", geojson=geojson_data)\n</code></pre>"},{"location":"guides/features/#using-geopandas-geodataframe","title":"Using GeoPandas GeoDataFrame","text":"<pre><code>import geopandas as gpd\nfrom shapely.geometry import Polygon\n\n# Create a GeoDataFrame with road polygons\npolygon = Polygon([\n    (-120.5, 39.5),\n    (-120.5, 39.6),\n    (-120.4, 39.6),\n    (-120.4, 39.5),\n    (-120.5, 39.5)\n])\n\ngdf = gpd.GeoDataFrame({\n    'geometry': [polygon],\n    'name': ['highway_1']\n}, crs=\"EPSG:4326\")\n\n# Create road features from GeoDataFrame\nroad = features.create_road_feature_from_geodataframe(gdf)\n\n# Or with in_place=True\nroad = features.create_road_feature_from_geodataframe(gdf, in_place=True)\n</code></pre> <p>!!! note \"GeoJSON Requirements\"     - Must contain Polygon or MultiPolygon geometries (area-based features)     - Geometries will be automatically clipped to the domain boundary     - For non-local CRS, geometries are transformed to match the domain's CRS</p>"},{"location":"guides/features/#wait-for-processing","title":"Wait for Processing","text":"<p>Road feature creation happens asynchronously. Wait for processing to complete:</p> <pre><code># Wait with status updates\nroad.wait_until_completed(\n    step=5,          # Check every 5 seconds\n    timeout=300,     # Wait up to 5 minutes\n    verbose=True     # Print status updates\n)\n\nprint(f\"Status: {road.status}\")  # Should print 'completed'\n</code></pre>"},{"location":"guides/features/#create-water-features","title":"Create Water Features","text":""},{"location":"guides/features/#basic-water-feature-creation","title":"Basic Water Feature Creation","text":"<p>Similar to roads, create water features from OSM data:</p> <pre><code># Using the convenience method\nwater = features.create_water_feature_from_osm()\n\n# Or the general method\nwater = features.create_water_feature(sources=\"OSM\")\n\n# Wait for processing\nwater.wait_until_completed(in_place=True)\n</code></pre>"},{"location":"guides/features/#update-features-instance_1","title":"Update Features Instance","text":"<p>To automatically update the Features object:</p> <pre><code>water = features.create_water_feature_from_osm(in_place=True)\nassert features.water is water\n</code></pre>"},{"location":"guides/features/#get-updated-feature-data","title":"Get Updated Feature Data","text":""},{"location":"guides/features/#refresh-all-features","title":"Refresh All Features","text":"<p>To get the latest data for all features:</p> <pre><code># Get new instance with fresh data\nupdated_features = features.get()\n\n# Or update in place\nfeatures.get(in_place=True)\n</code></pre>"},{"location":"guides/features/#refresh-specific-features","title":"Refresh Specific Features","text":"<p>To update just road or water features:</p> <pre><code>if features.road:\n    # Get new instance with fresh data\n    updated_road = features.road.get()\n\n    # Or update in place\n    features.road.get(in_place=True)\n\nif features.water:\n    # Get new instance with fresh data\n    updated_water = features.water.get()\n\n    # Or update in place\n    features.water.get(in_place=True)\n</code></pre>"},{"location":"guides/features/#delete-features","title":"Delete Features","text":""},{"location":"guides/features/#delete-road-features","title":"Delete Road Features","text":"<p>To remove road features from a domain:</p> <pre><code>if features.road:\n    # Delete the road features\n    features.road.delete()\n\n    # Refresh features to reflect deletion\n    features.get(in_place=True)\n    assert features.road is None\n</code></pre>"},{"location":"guides/features/#delete-water-features","title":"Delete Water Features","text":"<p>Similarly for water features:</p> <pre><code>if features.water:\n    # Delete the water features\n    features.water.delete()\n\n    # Refresh features to reflect deletion\n    features.get(in_place=True)\n    assert features.water is None\n</code></pre>"},{"location":"guides/features/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing how to work with both road and water features:</p> <pre><code>from fastfuels_sdk import Features\n\n# Get domain and features\nfeatures = Features.from_domain_id(\"your_domain_id\")\n\n# Create road features and wait for completion\nroad = features.create_road_feature_from_osm(in_place=True)\nroad.wait_until_completed(verbose=True)\n\n# Create water features and wait for completion\nwater = features.create_water_feature_from_osm(in_place=True)\nwater.wait_until_completed(verbose=True)\n\n# Get latest feature data\nfeatures.get(in_place=True)\n\n# Process based on feature status\nif features.road and features.road.status == \"completed\":\n    print(\"Road features ready\")\nif features.water and features.water.status == \"completed\":\n    print(\"Water features ready\")\n\n# Clean up when done\nif features.road:\n    features.road.delete()\nif features.water:\n    features.water.delete()\n</code></pre>"},{"location":"guides/grids/","title":"How to Work with Grids in FastFuels SDK","text":"<p>This guide shows you how to work with grid data in the FastFuels SDK. Grids contain spatial data about terrain, vegetation, and other features within a domain's boundaries.</p>"},{"location":"guides/grids/#creating-and-updating-grid-objects","title":"Creating and Updating Grid Objects","text":""},{"location":"guides/grids/#how-to-create-a-grids-object","title":"How to Create a Grids Object","text":"<p>To work with grids, you first need to create a Grids object from an existing domain ID. Here's how to do it:</p> <pre><code>from fastfuels_sdk import Grids\n\n# Create a Grids object from a domain ID\ndomain_id = \"abc123\"  # Replace with your domain ID\ngrids = Grids.from_domain_id(domain_id)\n</code></pre> <p>Once you have a Grids object, you can check which types of grids are available:</p> <pre><code># Check for available grid types\nif grids.tree:\n    print(\"Domain has tree canopy data\")\nif grids.surface:\n    print(\"Domain has surface fuel data\")\nif grids.topography:\n    print(\"Domain has elevation data\")\nif grids.feature:\n    print(\"Domain has geographic feature data\")\n</code></pre>"},{"location":"guides/grids/#how-to-update-grid-data","title":"How to Update Grid Data","text":"<p>Grid data can change over time as new data becomes available or processing completes. There are two ways to update your Grids object with the latest data:</p> <ol> <li> <p>Create a new Grids object with updated data: <pre><code># Get fresh data in a new instance\nupdated_grids = grids.get()\n</code></pre></p> </li> <li> <p>Update the existing Grids object in place: <pre><code># Update the existing instance\ngrids.get(in_place=True)\n</code></pre></p> </li> </ol> <p>Choose the first approach if you want to compare old and new data, or the second approach if you just want to ensure you're working with the latest data.</p>"},{"location":"guides/grids/#creating-grids-directly","title":"Creating Grids Directly","text":"<p>Once you have a Grids object, you can create different types of grids directly using its creation methods:</p>"},{"location":"guides/grids/#surface-grids","title":"Surface Grids","text":"<p>Surface grids contain data about surface fuels. Create them using <code>create_surface_grid()</code>:</p> <pre><code># Create a simple surface grid with uniform values\nsurface_grid = grids.create_surface_grid(\n    attributes=[\"fuelLoad\", \"fuelMoisture\"],\n    fuel_load={\"source\": \"uniform\", \"value\": 0.5},\n    fuel_moisture={\"source\": \"uniform\", \"value\": 15.0}\n)\n</code></pre>"},{"location":"guides/grids/#topography-grids","title":"Topography Grids","text":"<p>Topography grids contain elevation and terrain data. Create them using <code>create_topography_grid()</code>:</p> <pre><code># Create a topography grid using 3DEP data\ntopo_grid = grids.create_topography_grid(\n    attributes=[\"elevation\", \"slope\"],\n    elevation={\"source\": \"3DEP\", \"interpolationMethod\": \"cubic\"},\n    slope={\"source\": \"3DEP\", \"interpolationMethod\": \"cubic\"}\n)\n</code></pre>"},{"location":"guides/grids/#tree-grids","title":"Tree Grids","text":"<p>Tree grids contain canopy and tree data. Create them using <code>create_tree_grid()</code>:</p> <pre><code># Create a tree grid with inventory and uniform values\ntree_grid = grids.create_tree_grid(\n    attributes=[\"bulkDensity\", \"SPCD\", \"fuelMoisture\"],\n    bulk_density={\"source\": \"inventory\"},\n    spcd={\"source\": \"inventory\"},\n    fuel_moisture={\"source\": \"uniform\", \"value\": 15.0}\n)\n</code></pre>"},{"location":"guides/grids/#feature-grids","title":"Feature Grids","text":"<p>Feature grids contain geographic features. Create them using <code>create_feature_grid()</code>:</p> <pre><code># Create a feature grid with roads and water bodies\nfeature_grid = grids.create_feature_grid(\n    attributes=[\"road\", \"water\"]\n)\n</code></pre>"},{"location":"guides/grids/#using-grid-builders","title":"Using Grid Builders","text":"<p>For more complex grid configurations, FastFuels SDK provides builder classes that offer a fluent interface and better parameter validation. The builders help construct grid configurations step by step.</p> <p>Key benefits of using builders: - Clearer, more readable code - Better parameter validation - Chainable methods - Reusable configurations</p>"},{"location":"guides/grids/#surface-grid-builder","title":"Surface Grid Builder","text":"<p>The SurfaceGridBuilder helps create surface grids with complex configurations:</p> <pre><code>from fastfuels_sdk import SurfaceGridBuilder\n\n# Create a surface grid with multiple attributes\nsurface_grid = (SurfaceGridBuilder(\"abc123\")\n    .with_fuel_load_from_landfire(\n        product=\"FBFM40\",\n        version=\"2022\",\n        feature_masks=[\"road\", \"water\"]\n    )\n    .with_uniform_fuel_moisture_by_size_class(\n        one_hour=10.0,\n        ten_hour=15.0,\n        hundred_hour=20.0,\n        live_herbaceous=75.0,\n        live_woody=90.0\n    )\n    .with_modification(\n        actions={\"attribute\": \"FBFM\", \"modifier\": \"replace\", \"value\": \"GR2\"},\n        conditions={\"attribute\": \"FBFM\", \"operator\": \"eq\", \"value\": \"GR1\"}\n    )\n    .build())\n</code></pre>"},{"location":"guides/grids/#topography-grid-builder","title":"Topography Grid Builder","text":"<p>The TopographyGridBuilder helps create topography grids:</p> <pre><code>from fastfuels_sdk import TopographyGridBuilder\n\n# Create a topography grid with multiple data sources\ntopo_grid = (TopographyGridBuilder(\"abc123\")\n    .with_elevation_from_3dep(interpolation_method=\"cubic\")\n    .with_slope_from_landfire(interpolation_method=\"cubic\")\n    .with_aspect_from_3dep()\n    .build())\n</code></pre>"},{"location":"guides/grids/#tree-grid-builder","title":"Tree Grid Builder","text":"<p>The TreeGridBuilder helps create tree grids:</p> <pre><code>from fastfuels_sdk import TreeGridBuilder\n\n# Create a tree grid with inventory and uniform values\ntree_grid = (TreeGridBuilder(\"abc123\")\n    .with_bulk_density_from_tree_inventory()\n    .with_spcd_from_tree_inventory()\n    .with_savr_from_tree_inventory()\n    .with_uniform_fuel_moisture(15.0)\n    .build())\n</code></pre>"},{"location":"guides/grids/#best-practices-for-builders","title":"Best Practices for Builders","text":"<p>When using grid builders:</p> <ol> <li> <p>Clear the builder if reusing it for multiple grids: <pre><code>builder = SurfaceGridBuilder(\"abc123\")\ngrid1 = builder.with_uniform_fuel_load(0.5).build()\nbuilder.clear()  # Reset the builder\ngrid2 = builder.with_uniform_fuel_moisture(15.0).build()\n</code></pre></p> </li> <li> <p>Chain methods for better readability: <pre><code>grid = (builder\n    .with_uniform_fuel_load(0.5)\n    .with_uniform_fuel_moisture(15.0)\n    .build())\n</code></pre></p> </li> <li> <p>Use feature masks when appropriate to improve grid resolution: <pre><code>grid = (builder\n    .with_fuel_load_from_landfire(\n        product=\"FBFM40\",\n        feature_masks=[\"road\", \"water\"],\n        remove_non_burnable=[\"NB1\", \"NB2\"]\n    )\n    .build())\n</code></pre></p> </li> </ol>"},{"location":"guides/grids/#exporting-grid-data","title":"Exporting Grid Data","text":"<p>The Grids object provides methods to export grid data in different formats for use in fire behavior models. The two main export formats are:</p> <ul> <li>\"zarr\": A compressed array format for general use</li> <li>\"QUIC-Fire\": Specific format for the QUIC-Fire fire behavior model</li> </ul>"},{"location":"guides/grids/#how-to-export-to-quic-fire-format","title":"How to Export to QUIC-Fire Format","text":"<p>To export your grid data for use with QUIC-Fire:</p> <pre><code># Create the export\nexport = grids.create_export(\"QUIC-Fire\")\n\n# Wait for the export to complete\nexport.wait_until_completed()\n\n# Save to a file\nexport.to_file(\"grid_data.zip\")\n</code></pre> <p>The QUIC-Fire export creates a zip file containing: - <code>treesrhof.dat</code>: Bulk density data - <code>treesmoist.dat</code>: Moisture content data - <code>treesdepth.dat</code>: Canopy depth data - <code>topo.dat</code>: Topography data (if available)</p>"},{"location":"guides/grids/#how-to-check-export-status","title":"How to Check Export Status","text":"<p>You can check the status of an existing export:</p> <pre><code># Get the current status of an export\nexport = grids.get_export(\"QUIC-Fire\")\n\n# Check if it's ready\nif export.status == \"completed\":\n    export.to_file(\"grid_data.zip\")\n</code></pre>"},{"location":"guides/grids/#export-best-practices","title":"Export Best Practices","text":"<p>When working with exports:</p> <ol> <li> <p>Always wait for completion before saving: <pre><code>export = grids.create_export(\"QUIC-Fire\")\nexport.wait_until_completed()  # Blocks until export is ready\nexport.to_file(\"output.zip\")\n</code></pre></p> </li> <li> <p>Handle exports asynchronously for large datasets: <pre><code>export = grids.create_export(\"QUIC-Fire\")\n# Do other work while export processes\nstatus = grids.get_export(\"QUIC-Fire\")\nif status.status == \"completed\":\n    export.to_file(\"output.zip\")\n</code></pre></p> </li> <li> <p>Use zarr format for programmatic access to the data: <pre><code>export = grids.create_export(\"zarr\")\nexport.wait_until_completed()\nexport.to_file(\"grid_data.zarr\")\n</code></pre></p> </li> </ol>"},{"location":"guides/inventories/","title":"How to Work with FastFuels Inventories","text":"<p>This guide shows you how to accomplish common tasks with FastFuels inventories. For learning the basics, see the [Getting Started tutorial]. For detailed reference, see the [API Reference].</p>"},{"location":"guides/inventories/#how-to-create-a-tree-inventory-from-treemap-data","title":"How to Create a Tree Inventory from TreeMap Data","text":"<p>To generate a tree inventory using TreeMap's nationwide coverage:</p> <pre><code>from fastfuels_sdk import Inventories\n\n# Initialize from your domain\ninventories = Inventories.from_domain_id(\"your_domain_id\")\n\n# Create basic inventory\ntree_inventory = inventories.create_tree_inventory_from_treemap()\n\n# Wait for processing to complete\ntree_inventory = tree_inventory.wait_until_completed()\n</code></pre> <p>To make the inventory reproducible, specify a seed:</p> <pre><code>tree_inventory = inventories.create_tree_inventory_from_treemap(\n    version=\"2016\",\n    seed=42\n)\n</code></pre> <p>To use high-resolution canopy height data for improved tree height estimates:</p> <pre><code>tree_inventory = inventories.create_tree_inventory_from_treemap(\n    canopy_height_map_source=\"Meta2024\"\n)\n</code></pre>"},{"location":"guides/inventories/#how-to-upload-your-own-tree-data","title":"How to Upload Your Own Tree Data","text":"<p>If you have your own tree measurements, you can upload them from a CSV file:</p> <pre><code>from pathlib import Path\n\n# Create inventory from your CSV file\ntree_inventory = inventories.create_tree_inventory_from_file_upload(\n    file_path=Path(\"my_trees.csv\")\n)\n\n# Wait for processing\ntree_inventory = tree_inventory.wait_until_completed()\n</code></pre> <p>Your CSV file must include these columns: - TREE_ID (Integer): Unique identifier for each tree - SPCD (Integer): FIA species code - STATUSCD (Integer): Tree status (1: Live, 2: Dead, etc.) - DIA (Float): Diameter in cm - HT (Float): Height in meters - CR (Float): Crown ratio (0-1) - X (Float): X coordinate - Y (Float): Y coordinate</p>"},{"location":"guides/inventories/#how-to-modify-tree-attributes","title":"How to Modify Tree Attributes","text":"<p>To adjust tree measurements based on conditions:</p> <pre><code># Reduce height of all trees over 20m by 10%\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    modifications={\n        \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n        \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n    }\n)\n</code></pre> <p>To remove trees from roads and water bodies:</p> <pre><code>tree_inventory = inventories.create_tree_inventory_from_treemap(\n    feature_masks=[\"road\", \"water\"]\n)\n</code></pre> <p>To remove trees based on attribute conditions:</p> <pre><code># Remove all trees with diameter less than 10cm\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    modifications={\n        \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n        \"actions\": [{\"attribute\": \"all\", \"modifier\": \"remove\"}]\n    }\n)\n</code></pre> <p>You can also combine multiple modifications, including removal:</p> <pre><code># Reduce height of tall trees AND remove small trees\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    modifications=[\n        {\n            \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n            \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n        },\n        {\n            \"conditions\": [{\"attribute\": \"DIA\", \"operator\": \"lt\", \"value\": 10}],\n            \"actions\": [{\"modifier\": \"remove\"}]\n        }\n    ]\n)\n</code></pre>"},{"location":"guides/inventories/#using-expression-based-conditions","title":"Using Expression-Based Conditions","text":"<p>For more complex filtering, you can use arithmetic expressions that combine multiple tree fields. This eliminates the need to download, filter with pandas, and re-upload data.</p> <p>Remove trees with short crowns (crown length &lt; 1m):</p> <pre><code>tree_inventory = inventories.create_tree_inventory_from_treemap(\n    modifications={\n        \"conditions\": [{\n            \"attribute\": \"expression\",\n            \"expression\": \"HT * CR\",  # Crown length = height \u00d7 crown ratio\n            \"operator\": \"lt\",\n            \"value\": 1.0\n        }],\n        \"actions\": [{\"modifier\": \"remove\"}]\n    }\n)\n</code></pre> <p>Remove unrealistic slender trees (height/diameter ratio &gt; 100):</p> <pre><code>tree_inventory = inventories.create_tree_inventory_from_treemap(\n    modifications={\n        \"conditions\": [{\n            \"attribute\": \"expression\",\n            \"expression\": \"HT / DIA\",  # Slenderness ratio\n            \"operator\": \"gt\",\n            \"value\": 100.0\n        }],\n        \"actions\": [{\"modifier\": \"remove\"}]\n    }\n)\n</code></pre> <p>Combine field and expression conditions (remove tall, slender Douglas-fir):</p> <pre><code>tree_inventory = inventories.create_tree_inventory_from_treemap(\n    modifications={\n        \"conditions\": [\n            {\"attribute\": \"SPCD\", \"operator\": \"eq\", \"value\": 202},  # Douglas-fir\n            {\"attribute\": \"expression\", \"expression\": \"HT / DIA\", \"operator\": \"gt\", \"value\": 100}\n        ],\n        \"actions\": [{\"modifier\": \"remove\"}]\n    }\n)\n</code></pre> <p>Supported expression fields: <code>HT</code> (height), <code>DIA</code> (diameter), <code>CR</code> (crown ratio) Supported operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>()</code> Common patterns: - Crown length: <code>HT * CR</code> - Crown base height: <code>HT * (1 - CR)</code> - Slenderness ratio: <code>HT / DIA</code> - Average metric: <code>(HT + DIA) / 2</code></p>"},{"location":"guides/inventories/#how-to-apply-forest-management-treatments","title":"How to Apply Forest Management Treatments","text":"<p>To thin to a target basal area:</p> <pre><code># Thin to 25 m\u00b2/ha basal area\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    treatments={\n        \"method\": \"proportionalThinning\",\n        \"targetMetric\": \"basalArea\",\n        \"targetValue\": 25.0\n    }\n)\n</code></pre> <p>To remove trees below a diameter threshold:</p> <pre><code># Remove trees under 30cm diameter\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    treatments={\n        \"method\": \"directionalThinning\",\n        \"direction\": \"below\",\n        \"targetMetric\": \"diameter\",\n        \"targetValue\": 30.0\n    }\n)\n</code></pre>"},{"location":"guides/inventories/#how-to-export-inventory-data","title":"How to Export Inventory Data","text":"<p>To save your inventory data to a file:</p> <pre><code># Create export in desired format\nexport = tree_inventory.create_export(\"csv\")  # or \"parquet\" or \"geojson\"\nexport = export.wait_until_completed()\n\n# Download to specific file\nexport.to_file(\"trees.csv\")\n\n# Or download to directory (uses default filename)\nexport.to_file(Path(\"output_directory\"))\n</code></pre>"},{"location":"guides/inventories/#how-to-manage-existing-inventories","title":"How to Manage Existing Inventories","text":"<p>To check if inventories exist:</p> <pre><code>inventories = inventories.get()\nif inventories.tree:\n    print(\"Tree inventory exists\")\n</code></pre> <p>To delete an inventory:</p> <pre><code>if inventories.tree:\n    inventories.tree.delete()\n</code></pre>"},{"location":"guides/inventories/#common-workflows","title":"Common Workflows","text":""},{"location":"guides/inventories/#complete-processing-pipeline","title":"Complete Processing Pipeline","text":"<p>If you need to create an inventory with multiple modifications:</p> <pre><code># Create inventory with multiple settings\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    seed=42,\n    modifications={\n        \"conditions\": [{\"attribute\": \"HT\", \"operator\": \"gt\", \"value\": 20}],\n        \"actions\": [{\"attribute\": \"HT\", \"modifier\": \"multiply\", \"value\": 0.9}]\n    },\n    treatments={\n        \"method\": \"proportionalThinning\",\n        \"targetMetric\": \"basalArea\",\n        \"targetValue\": 25.0\n    },\n    feature_masks=[\"road\", \"water\"]\n)\n\n# Wait for processing and export\ntree_inventory = tree_inventory.wait_until_completed()\nexport = tree_inventory.create_export(\"csv\")\nexport = export.wait_until_completed()\nexport.to_file(\"processed_trees.csv\")\n</code></pre>"},{"location":"guides/inventories/#converting-your-data-to-fastfuels-format","title":"Converting Your Data to FastFuels Format","text":"<p>To process your own tree measurements and apply treatments:</p> <pre><code># Upload your data\ntree_inventory = inventories.create_tree_inventory_from_file_upload(\n    file_path=Path(\"field_measurements.csv\")\n)\n\n# Wait for processing\ntree_inventory = tree_inventory.wait_until_completed()\n\n# Apply treatments and export\ntree_inventory = inventories.create_tree_inventory_from_treemap(\n    treatments={\n        \"method\": \"proportionalThinning\",\n        \"targetMetric\": \"basalArea\",\n        \"targetValue\": 25.0\n    }\n)\ntree_inventory = tree_inventory.wait_until_completed()\n\n# Export results\nexport = tree_inventory.create_export(\"csv\")\nexport = export.wait_until_completed()\nexport.to_file(\"processed_measurements.csv\")\n</code></pre>"},{"location":"tutorials/export_to_quicfire/","title":"Export to QUIC-Fire","text":"<p>from grids.test_feature_grid import feature_grid_fixture</p>"},{"location":"tutorials/export_to_quicfire/#tutorial-create-and-export-quic-fire-inputs-with-fastfuels-sdk","title":"Tutorial: Create and Export QUIC-Fire Inputs with FastFuels SDK","text":"<p>In this tutorial, you'll learn how to use the FastFuels SDK to create QUIC-Fire input files for a region of interest. We'll walk through each step of the process, from authentication to final export.</p>"},{"location":"tutorials/export_to_quicfire/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, make sure you have: - FastFuels SDK installed (<code>pip install fastfuels-sdk</code>) - A valid FastFuels API key - Basic familiarity with Python and GeoPandas</p>"},{"location":"tutorials/export_to_quicfire/#what-youll-learn","title":"What You'll Learn","text":"<p>By the end of this tutorial, you'll know how to: - Set up authentication for the FastFuels SDK - Create and work with Domains - Generate grids for fuels and topography - Export the data to QUIC-Fire format - Use the convenience function for simplified workflows</p>"},{"location":"tutorials/export_to_quicfire/#step-1-set-up-authentication","title":"Step 1: Set Up Authentication","text":"<p>First, let's configure the SDK with your API key. While you can use environment variables, we'll set it programmatically for this tutorial:</p> <pre><code>from fastfuels_sdk import api\n\n# Configure the API key\napi.set_api_key(\"your-api-key-here\")\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-2-create-a-region-of-interest","title":"Step 2: Create a Region of Interest","text":"<p>Let's create a GeoDataFrame representing an area in the Blue Mountain Recreation Area:</p> <pre><code>import geopandas as gpd\nfrom shapely.geometry import Polygon\n\n# Define the polygon coordinates for Blue Mountain area\ncoordinates = [\n    [-114.09957018646286, 46.82933208815811],\n    [-114.10141707482919, 46.828370407248826],\n    [-114.10010954324228, 46.82690548814563],\n    [-114.09560673134018, 46.8271123684554],\n    [-114.09592544216444, 46.829058122675065],\n    [-114.09957018646286, 46.82933208815811]\n]\n\n# Create a GeoDataFrame\npolygon = Polygon(coordinates)\nroi = gpd.GeoDataFrame(\n    geometry=[polygon],\n    crs=\"EPSG:4326\"  # WGS 84 coordinate system\n)\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-3-create-a-domain","title":"Step 3: Create a Domain","text":"<p>Now let's create a Domain from our ROI:</p> <pre><code>from fastfuels_sdk.domains import Domain\n\ndomain = Domain.from_geodataframe(\n    geodataframe=roi,\n    name=\"Blue Mountain ROI\",\n    description=\"Test area in Blue Mountain Recreation Area\",\n    horizontal_resolution=2.0,  # 2-meter horizontal resolution\n    vertical_resolution=1.0     # 1-meter vertical resolution\n)\n\nprint(f\"Created domain with ID: {domain.id}\")\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-4-create-road-and-water-features","title":"Step 4: Create Road and Water Features","text":"<p>Let's add road and water features from OpenStreetMap:</p> <pre><code>from fastfuels_sdk.features import Features\n\n# Initialize Features for our domain\nfeatures = Features.from_domain_id(domain.id)\n\n# Create features from OpenStreetMap\nroad_feature = features.create_road_feature_from_osm()\nwater_feature = features.create_water_feature_from_osm()\n\n# Wait for features to be ready\nroad_feature.wait_until_completed()\nwater_feature.wait_until_completed()\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-5-create-feature-grid","title":"Step 5: Create Feature Grid","text":"<p>Next, use the road and water features we created in Step 4 to generate a feature grid:</p> <pre><code>from fastfuels_sdk.grids import Grids\n\n# Create feature grid\nfeature_grid = (\n    Grids.from_domain_id(domain.id)\n    .create_feature_grid(\n        attributes=[\"road\", \"water\"],\n    )\n)\n\nfeature_grid.wait_until_completed()\n</code></pre> <p>This will be used to mask out trees and non-burnable areas when we create the tree inventory in Step 7 and the surface grid in Step 8.</p>"},{"location":"tutorials/export_to_quicfire/#step-6-create-topography-grid","title":"Step 6: Create Topography Grid","text":"<p>Add elevation data from 3DEP:</p> <pre><code>from fastfuels_sdk.grids import TopographyGridBuilder\n\ntopography_grid = (\n    TopographyGridBuilder(domain_id=domain.id)\n    .with_elevation_from_3dep(interpolation_method=\"linear\")\n    .build()\n)\n\ntopography_grid.wait_until_completed()\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-7-create-tree-inventory-and-grid","title":"Step 7: Create Tree Inventory and Grid","text":"<p>Create a tree inventory and generate the canopy fuel grid:</p> <pre><code>from fastfuels_sdk.inventories import Inventories\nfrom fastfuels_sdk.grids import TreeGridBuilder\n\n# Create tree inventory\ntree_inventory = Inventories.from_domain_id(\n    domain.id\n).create_tree_inventory_from_treemap(\n    feature_masks=[\"road\", \"water\"]\n)\ntree_inventory.wait_until_completed()\n\n# Create tree grid\ntree_grid = (\n    TreeGridBuilder(domain_id=domain.id)\n    .with_bulk_density_from_tree_inventory()\n    .build()\n)\ntree_grid.wait_until_completed()\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-8-create-surface-grid","title":"Step 8: Create Surface Grid","text":"<p>Generate the surface fuels grid:</p> <pre><code>from fastfuels_sdk.grids import SurfaceGridBuilder\n\nsurface_grid = (\n    SurfaceGridBuilder(domain_id=domain.id)\n    .with_fuel_load_from_landfire(\n        product=\"FBFM40\",\n        version=\"2022\",\n        interpolation_method=\"cubic\",\n        curing_live_herbaceous=0.25,\n        curing_live_woody=0.1,\n        groups=[\"oneHour\"],\n        feature_masks=[\"road\", \"water\"],\n        remove_non_burnable=[\"NB1\", \"NB2\"],\n    )\n    .with_fuel_depth_from_landfire(\n        product=\"FBFM40\",\n        version=\"2022\",\n        interpolation_method=\"cubic\",\n        feature_masks=[\"road\", \"water\"],\n        remove_non_burnable=[\"NB1\", \"NB2\"],\n    )\n    .with_uniform_fuel_moisture(\n        value=0.15,\n        feature_masks=[\"road\", \"water\"]\n    )\n    .build()\n)\nsurface_grid.wait_until_completed()\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#step-9-export-to-quic-fire-format","title":"Step 9: Export to QUIC-Fire Format","text":"<p>Create and download the QUIC-Fire export:</p> <pre><code>from fastfuels_sdk.grids import Grids\nfrom pathlib import Path\n\n# Create the export\nexport = Grids.from_domain_id(domain.id).create_export(\"QUIC-Fire\")\nexport.wait_until_completed()\n\n# Download to a local directory\nexport_path = Path(\"quicfire_export\")\nexport.to_file(export_path)\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#using-the-convenience-function","title":"Using the Convenience Function","text":"<p>Now that you understand the complete process, you can use the convenience function to accomplish the same result with less code:</p> <pre><code>from fastfuels_sdk import export_roi\n\n# Export using the convenience function (defaults to QUIC-Fire format)\nexport = export_roi(\n    roi=roi,\n    export_path=Path(\"quicfire_export\"),\n    verbose=True  # See progress updates\n)\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#export-formats","title":"Export Formats","text":"<p>The <code>export_roi()</code> function supports multiple export formats via the <code>export_format</code> parameter:</p> <pre><code># Export to QUIC-Fire format (default)\nexport = export_roi(roi, \"quicfire_export.zip\", export_format=\"QUIC-Fire\")\n\n# Export to zarr format\nexport = export_roi(roi, \"zarr_export.zip\", export_format=\"zarr\")\n</code></pre> <p>For backwards compatibility, you can also use <code>export_roi_to_quicfire()</code> which is a convenience wrapper that always exports to QUIC-Fire format:</p> <pre><code>from fastfuels_sdk import export_roi_to_quicfire\n\nexport = export_roi_to_quicfire(roi, \"quicfire_export.zip\", verbose=True)\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#customizing-the-export-with-configuration-options","title":"Customizing the Export with Configuration Options","text":"<p>Both <code>export_roi()</code> and <code>export_roi_to_quicfire()</code> support extensive configuration options that let you customize every aspect of the export process. Instead of writing complex builder chains (as shown in the manual process above), you can use simple dictionary-based configurations that mirror the underlying API structures.</p> <p>Why use configuration dictionaries? They provide the same power as the manual approach but with much simpler syntax. Each configuration parameter directly maps to the builder methods you saw earlier:</p> <ul> <li><code>surface_config</code> \u2192 <code>SurfaceGridBuilder</code> methods</li> <li><code>topography_config</code> \u2192 <code>TopographyGridBuilder</code> methods</li> <li><code>tree_config</code> \u2192 <code>TreeGridBuilder</code> methods</li> <li><code>features_config</code> \u2192 Feature creation controls</li> <li><code>tree_inventory_config</code> \u2192 Tree inventory parameters</li> </ul>"},{"location":"tutorials/export_to_quicfire/#most-common-use-cases","title":"Most Common Use Cases","text":"<p>Change surface fuel moisture (the #1 most common customization):</p> <p>This replaces the manual <code>.with_uniform_fuel_moisture()</code> call from Step 8 above:</p> <pre><code># Set surface fuel moisture to 5% for dry conditions\nsurface_config = {\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",\n        \"value\": 0.05,  # 5% moisture content\n        \"featureMasks\": [\"road\", \"water\"]\n    }\n}\n\nexport = export_roi(\n    roi, \"dry_conditions_export\",\n    surface_config=surface_config,\n    verbose=True\n)\n</code></pre> <p>Use newer LANDFIRE data:</p> <p>This replaces the <code>version=\"2022\"</code> parameters from the manual process:</p> <pre><code># Use LANDFIRE 2023 data instead of default 2022\nsurface_config = {\n    \"fuelLoad\": {\"version\": \"2023\"},\n    \"fuelDepth\": {\"version\": \"2023\"}\n}\n\nexport = export_roi(\n    roi, \"landfire_2023_export\",\n    surface_config=surface_config\n)\n</code></pre> <p>Skip water features for faster processing:</p> <p>This replaces the manual feature creation from Step 4:</p> <pre><code># Skip water feature creation (roads only)\nfeatures_config = {\n    \"createWaterFeatures\": False\n}\n\nexport = export_roi(\n    roi, \"roads_only_export\",\n    features_config=features_config\n)\n\n#### Complete Configuration Reference\n\n##### Topography Configuration\n\n```python\ntopography_config = {\n    \"attributes\": [\"elevation\"],\n    \"elevation\": {\n        \"source\": \"3DEP\",  # \"3DEP\", \"LANDFIRE\", or \"uniform\"\n        \"interpolationMethod\": \"linear\"  # \"linear\", \"cubic\", or \"nearest\"\n        # For uniform source only:\n        # \"value\": 1500.0  # Elevation in meters\n    }\n}\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#surface-configuration","title":"Surface Configuration","text":"<pre><code>surface_config = {\n    \"attributes\": [\"fuelLoad\", \"fuelDepth\", \"fuelMoisture\"],\n\n    \"fuelLoad\": {\n        \"source\": \"LANDFIRE\",  # \"LANDFIRE\" or \"uniform\"\n        \"product\": \"FBFM40\",   # LANDFIRE product\n        \"version\": \"2022\",     # LANDFIRE version year\n        \"interpolationMethod\": \"cubic\",\n        \"curingLiveHerbaceous\": 0.25,  # 0.0-1.0\n        \"curingLiveWoody\": 0.1,        # 0.0-1.0\n        \"groups\": [\"oneHour\", \"tenHour\", \"hundredHour\", \"liveHerbaceous\", \"liveWoody\"],\n        \"featureMasks\": [\"road\", \"water\"],\n        \"removeNonBurnable\": [\"NB1\", \"NB2\", \"NB3\", \"NB8\", \"NB9\"],\n        # For uniform source only:\n        # \"value\": 2.5  # kg/m\u00b2\n    },\n\n    \"fuelDepth\": {\n        \"source\": \"LANDFIRE\",  # Similar structure to fuelLoad\n        \"product\": \"FBFM40\",\n        \"version\": \"2022\",\n        \"interpolationMethod\": \"cubic\",\n        \"featureMasks\": [\"road\", \"water\"],\n        \"removeNonBurnable\": [\"NB1\", \"NB2\", \"NB3\", \"NB8\", \"NB9\"]\n        # For uniform: \"value\": 0.3  # meters\n    },\n\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",  # Currently only uniform supported\n        \"value\": 0.15,        # Moisture content (0.0-1.0)\n        \"featureMasks\": [\"road\", \"water\"]\n    }\n}\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#tree-configuration","title":"Tree Configuration","text":"<pre><code>tree_config = {\n    \"attributes\": [\"bulkDensity\", \"fuelMoisture\"],\n\n    \"bulkDensity\": {\n        \"source\": \"inventory\",  # \"inventory\" or \"uniform\"\n        # For uniform source only:\n        # \"value\": 0.5  # kg/m\u00b3\n    },\n\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",\n        \"value\": 100  # Moisture content (typically 50-150)\n    }\n}\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#features-configuration","title":"Features Configuration","text":"<pre><code>features_config = {\n    \"createRoadFeatures\": True,     # Create road features from OSM\n    \"createWaterFeatures\": True,    # Create water features from OSM\n    \"featureGridAttributes\": [\"road\", \"water\"]  # Grid attributes to create\n}\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#tree-inventory-configuration","title":"Tree Inventory Configuration","text":"<pre><code>tree_inventory_config = {\n    \"version\": \"2022\",  # TreeMap version: \"2014\", \"2016\", \"2020\", \"2022\"\n    \"seed\": 42,  # Random seed for reproducibility (optional)\n    \"featureMasks\": [\"road\", \"water\"],  # Features to mask from inventory\n    \"canopyHeightMapSource\": \"Meta2024\",  # High-resolution canopy height data\n\n    # Tree attribute modifications (optional)\n    \"modifications\": [\n        {\n            \"conditions\": [\n                {\"attribute\": \"CR\", \"operator\": \"gt\", \"value\": 0.1}\n            ],\n            \"actions\": [\n                {\"attribute\": \"CR\", \"modifier\": \"multiply\", \"value\": 0.9}\n            ]\n        }\n    ],\n\n    # Silvicultural treatments (optional)\n    \"treatments\": [\n        {\n            \"method\": \"proportionalThinning\",\n            \"targetMetric\": \"basalArea\",\n            \"targetValue\": 25.0\n        }\n    ]\n}\n</code></pre> <p>Available modification attributes: - <code>HT</code>: Height (meters) - <code>DIA</code>: Diameter at breast height (centimeters) - <code>CR</code>: Crown ratio (0-1) - crown length = height \u00d7 crown ratio - <code>SPCD</code>: Species code (integer)</p> <p>Available operators: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>lt</code>, <code>ge</code>, <code>le</code></p> <p>Available modifiers: <code>multiply</code>, <code>divide</code>, <code>add</code>, <code>subtract</code>, <code>replace</code>, <code>remove</code></p> <p>Treatment methods: - <code>proportionalThinning</code>: Thin to target basal area (m\u00b2/ha) - <code>directionalThinning</code>: Remove trees above/below size threshold</p>"},{"location":"tutorials/export_to_quicfire/#advanced-configuration-examples","title":"Advanced Configuration Examples","text":"<p>Completely custom surface grid:</p> <pre><code>surface_config = {\n    \"fuelLoad\": {\n        \"source\": \"uniform\",\n        \"value\": 1.5,  # kg/m\u00b2\n        \"featureMasks\": [\"road\"]  # Only mask roads, not water\n    },\n    \"fuelDepth\": {\n        \"source\": \"uniform\",\n        \"value\": 0.2,  # meters\n        \"featureMasks\": [\"road\"]\n    },\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",\n        \"value\": 0.08,  # Very dry conditions (8%)\n        \"featureMasks\": [\"road\"]\n    }\n}\n</code></pre> <p>High-resolution with cubic interpolation:</p> <pre><code>topography_config = {\n    \"elevation\": {\n        \"source\": \"3DEP\",\n        \"interpolationMethod\": \"cubic\"  # Higher quality interpolation\n    }\n}\n\nsurface_config = {\n    \"fuelLoad\": {\n        \"interpolationMethod\": \"cubic\",\n        \"groups\": [\"oneHour\", \"tenHour\", \"hundredHour\"]  # Include more fuel classes\n    },\n    \"fuelDepth\": {\n        \"interpolationMethod\": \"cubic\"\n    }\n}\n</code></pre> <p>Roads-only configuration:</p> <pre><code>features_config = {\n    \"createRoadFeatures\": True,\n    \"createWaterFeatures\": False,    # Skip water features\n    \"featureGridAttributes\": [\"road\"]  # Only roads in feature grid\n}\n\n# Update other configs to only mask roads\nsurface_config = {\n    \"fuelMoisture\": {\n        \"source\": \"uniform\",\n        \"value\": 0.12,\n        \"featureMasks\": [\"road\"]  # Only road masks\n    }\n}\n\ntree_inventory_config = {\n    \"featureMasks\": [\"road\"]  # Only mask roads from tree inventory\n}\n</code></pre>"},{"location":"tutorials/export_to_quicfire/#configuration-tips","title":"Configuration Tips","text":"<ol> <li> <p>Partial Overrides: Only specify the parameters you want to change. The function will merge your configuration with sensible defaults.</p> </li> <li> <p>Feature Mask Consistency: Make sure <code>featureMasks</code> in your surface and tree configs match the features you're actually creating.</p> </li> <li> <p>Performance Trade-offs:</p> </li> <li><code>\"cubic\"</code> interpolation is higher quality but slower</li> <li>Disabling water features speeds up processing</li> <li> <p>Fewer fuel load groups process faster</p> </li> <li> <p>Validation: The function validates your configuration against the API requirements and will provide helpful error messages.</p> </li> <li> <p>Backwards Compatibility: Existing code without configuration parameters will continue to work exactly as before.</p> </li> </ol>"},{"location":"tutorials/export_to_quicfire/#verifying-the-export","title":"Verifying the Export","text":"<p>Check your export directory for the QUIC-Fire input files:</p> <pre><code># List the exported files\nfor file in Path(\"quicfire_export\").glob(\"*.dat\"):\n    print(f\"Found QUIC-Fire input file: {file.name}\")\n</code></pre> <p>You should see: - <code>treesrhof.dat</code>: Fuel bulk density - <code>treesmoist.dat</code>: Fuel moisture content - <code>treesfueldepth.dat</code>: Surface fuel bed depth - <code>topo.dat</code>: Elevation data</p>"},{"location":"tutorials/export_to_quicfire/#next-steps","title":"Next Steps","text":"<p>Now that you can create QUIC-Fire inputs, you might want to: - Experiment with different regions and resolutions - Customize the grid parameters for your specific needs - Learn about more advanced features of the FastFuels SDK</p>"},{"location":"tutorials/export_to_quicfire/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues: - Check that your API key is valid and properly configured - Verify that your ROI polygon is valid and uses the correct coordinate system - Ensure you have sufficient permissions to write to the export directory - Check the status of resources using their <code>status</code> property</p>"},{"location":"tutorials/point_cloud_example/","title":"Tutorial: Incorporate ALS Point Cloud Data into a FastFuels Domain","text":"<p>This tutorial demonstrates how to incorporate airborne laser scanning (ALS / LiDAR) point cloud data into an existing FastFuels domain. It utilizes a point cloud\u2013derived canopy structure to inform the tree inventory and canopy fuel grids, enabling higher\u2010fidelity fuels representation.</p>"},{"location":"tutorials/point_cloud_example/#prerequisites","title":"Prerequisites","text":"<p>Before starting this tutorial, make sure you have: - FastFuels SDK installed (<code>pip install fastfuels-sdk</code>) - A valid FastFuels API key - Basic familiarity with Python and GeoPandas</p>"},{"location":"tutorials/point_cloud_example/#what-youll-learn","title":"What You'll Learn","text":"<p>By the end of this tutorial, you'll know how to: - Create an ALS point cloud within a FastFuels domain - Generate a tree inventory informed by the ALS data</p>"},{"location":"tutorials/point_cloud_example/#step-1-create-a-fastfuels-domain","title":"Step 1: Create a FastFuels Domain","text":"<p>For the polygon created by the coordinates: <pre><code>import geopandas as gpd\nfrom shapely.geometry import Polygon\n\n# Define the polygon coordinates for Lubrecht area\ncoordinates = [\n    [-113.43635167116199,46.89738742250387],\n    [-113.44842074255764,46.8894785976307],\n    [-113.44763362920567,46.88740657162339],\n    [-113.44993666456837,46.8858524995899],\n    [-113.44923700825561,46.88429838253265],\n    [-113.44273603501621,46.88389988372731],\n    [-113.43538964373204,46.882365635689325],\n    [-113.42005550954369,46.88523484307359],\n    [-113.42329141999039,46.88919967571519],\n    [-113.42361209580038,46.892566564773205],\n    [-113.4263524163587,46.89527586047467],\n    [-113.42696461563226,46.895973083547176],\n    [-113.42853884233625,46.89916027357725],\n    [-113.42711037736427,46.90210825569156],\n    [-113.42798494775504,46.90336309078498],\n    [-113.42932595568779,46.903004569469715],\n    [-113.43241610440292,46.90099282206219],\n    [-113.43445676864847,46.8980248588519],\n    [-113.43635167116199,46.89738742250387]\n]\n\n# Create a GeoDataFrame\npolygon = Polygon(coordinates)\nroi = gpd.GeoDataFrame(\n    geometry=[polygon],\n    crs=\"EPSG:4326\"  # WGS 84 coordinate system\n)\n\nfrom fastfuels_sdk.domains import Domain\n\ndomain = Domain.from_geodataframe(\n    geodataframe=roi,\n    name=\"Blue Mountain ROI\",\n    description=\"Test area in Lubrecht Experimental Forest\",\n    horizontal_resolution=2.0,  # 2-meter horizontal resolution\n    vertical_resolution=1.0     # 1-meter vertical resolution\n)\n\nprint(f\"Created domain with ID: {domain.id}\")\n</code></pre></p>"},{"location":"tutorials/point_cloud_example/#step-2-create-an-als-point-cloud-within-fastfuels","title":"Step 2: Create an ALS point cloud within FastFuels","text":"<p>Next, use 3DEP data to generate a feature point cloud:</p> <pre><code># 1.\nfrom fastfuels_sdk.pointclouds import PointClouds\n\n# 2. Correct Method Name &amp; 3. Added Required 'sources' argument\nals_pointcloud = (\n    PointClouds.from_domain_id(domain.id)\n    .create_als_point_cloud(sources=[\"3DEP\"])\n)\n\n# This works because create_als_point_cloud returns the child object\nals_pointcloud.wait_until_completed()\n</code></pre>"},{"location":"tutorials/point_cloud_example/#step-3-create-tree-inventory-using-the-point-cloud-data","title":"Step 3: Create Tree Inventory using the point cloud data","text":"<p>Create a tree inventory and generate the canopy fuel grid:</p> <pre><code>from fastfuels_sdk.inventories import Inventories\nfrom fastfuels_sdk.grids import TreeGridBuilder\n\n# Create tree inventory\n# Note: Ensure Step 2 (Point Cloud creation) is fully completed before running this\ntree_inventory = Inventories.from_domain_id(\n    domain.id\n).create_tree_inventory_from_point_cloud()\ntree_inventory.wait_until_completed()\n</code></pre>"},{"location":"tutorials/point_cloud_example/#next-steps","title":"Next Steps","text":"<p>For additional guidance and complementary workflows, refer back to the \u201cCreate and Export QUIC-Fire Inputs with FastFuels SDK\u201d tutorial.</p>"}]}